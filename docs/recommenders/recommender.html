<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.4" />
<title>reclab.recommenders.recommender API documentation</title>
<meta name="description" content="Defines a set of base classes from which recommenders can inherit â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/highlight.min.js" integrity="sha256-eOgo0OtLL4cdq7RdwRUiGKLX9XsIJ7nGhWEKbohmVAQ=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>reclab.recommenders.recommender</code></h1>
</header>
<section id="section-intro">
<p>Defines a set of base classes from which recommenders can inherit.</p>
<p>Recommenders do not need to inherit from any of the classes here to interact with the environments.
However, a recommender that is used in our experiment framework must be a descendent of the
Recommender base class. All the other classes represent specific recommender variants that occur
often enough to be an abstract classes to inherit from.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Defines a set of base classes from which recommenders can inherit.

Recommenders do not need to inherit from any of the classes here to interact with the environments.
However, a recommender that is used in our experiment framework must be a descendent of the
Recommender base class. All the other classes represent specific recommender variants that occur
often enough to be an abstract classes to inherit from.
&#34;&#34;&#34;
import abc
import collections
import itertools

import numpy as np
import scipy


class Recommender(abc.ABC):
    &#34;&#34;&#34;The interface for recommenders.&#34;&#34;&#34;

    @property
    @abc.abstractmethod
    def name(self):
        &#34;&#34;&#34;Get the name of the recommender.&#34;&#34;&#34;
        raise NotImplementedError

    @property
    @abc.abstractmethod
    def hyperparameters(self):
        &#34;&#34;&#34;Get a dict of all the recommender&#39;s hyperparameters.&#34;&#34;&#34;
        raise NotImplementedError

    @abc.abstractmethod
    def reset(self, users=None, items=None, ratings=None):
        &#34;&#34;&#34;Reset the recommender with optional starting user, item, and rating data.

        Parameters
        ----------
        users : iterable, optional
            The starting users.
        items : iterable, optional
            The starting items.
        ratings : iterable, optional
            The starting ratings and the associated contexts in which each rating was made.

        &#34;&#34;&#34;
        raise NotImplementedError

    @abc.abstractmethod
    def update(self, users=None, items=None, ratings=None):
        &#34;&#34;&#34;Update the recommender with new user, item, and rating data.

        Parameters
        ----------
        users : iterable, optional
            The new users.
        items : iterable, optional
            The new items.
        ratings : iterable, optional
            The new ratings and the associated context in which each rating was made.

        &#34;&#34;&#34;
        raise NotImplementedError

    @abc.abstractmethod
    def recommend(self, user_contexts, num_recommendations):
        &#34;&#34;&#34;Recommend items to users.

        Parameters
        ----------
        user_contexts : iterable
            The setting each user is going to be recommended items in.
        num_recommendations : int
            The number of items to recommend to each user.

        Returns
        -------
        recs : iterable
            The recommendations made to each user. recs[i] represents the recommendations
            made to the i-th user in the user_contexts variable.
        predicted_ratings : iterable or None
            The predicted rating for each item recommended to each user. Where predicted_ratings[i]
            represents the predictions of recommended items on the i-th user in the user_contexts
            variable. Derived classes may simply return None if they do not directly estimate
            ratings when making recommendations.

        &#34;&#34;&#34;
        raise NotImplementedError


class PredictRecommender(Recommender):
    &#34;&#34;&#34;A recommender that makes recommendations based on its rating predictions.

    Data is primarily passed around through dicts for any recommenders derived from this class.
    Each user is assumed to have a unique hashable id, likewise for all items. User and item
    features as well as rating contexts are assumed to be dense arrays.

    Parameters
    ----------
    strategy : str, optional
        The item selection strategy to use.
        Valid strategies are:
            &#39;greedy&#39;: chooses the unseen item with largest predicted rating
            &#39;eps_greedy&#39;: with probability 1-eps chooses the unseen item with largest
                           predicted rating, with probability eps chooses a random unseen item
            &#39;thompson&#39;: picks an item with probability proportional to the expected rating

    &#34;&#34;&#34;

    def __init__(self, strategy=&#39;greedy&#39;):
        &#34;&#34;&#34;Create a new PredictRecommender object.&#34;&#34;&#34;
        # The features associated with each user.
        self._users = []
        # The features associated with each item.
        self._items = []
        # The matrix of all numerical ratings.
        self._ratings = scipy.sparse.csr_matrix((0, 0))
        # Keeps track of the history of contexts in which a user-item rating was made.
        self._rating_contexts = collections.defaultdict(list)
        # Since outer ids passed to the recommender can be arbitrary hashable objects we
        # use these four variables to keep track of which index (AKA inner ids)
        # correspond to each outer id.
        self._outer_to_inner_uid = {}
        self._inner_to_outer_uid = []
        self._outer_to_inner_iid = {}
        self._inner_to_outer_iid = []
        # The sampling strategy to use.
        self._strategy = strategy
        # A dict of all the recommender&#39;s hyperparameters.
        self._hyperparameters = {&#39;strategy&#39;: strategy}
        # The cached dense predictions, reset to None each time update is called.
        self._dense_predictions = None
        # Check that the strategy is of valid type.
        assert self._strategy.split(&#39;,&#39;)[0] in [&#39;greedy&#39;, &#39;eps_greedy&#39;, &#39;thompson&#39;]

    @property
    def hyperparameters(self):
        &#34;&#34;&#34;Get a dict of all the recommender&#39;s hyperparameters.&#34;&#34;&#34;
        return self._hyperparameters

    def reset(self, users=None, items=None, ratings=None):
        &#34;&#34;&#34;Reset the recommender with optional starting user, item, and rating data.

        Parameters
        ----------
        users : dict, optional
            The starting users where the key is the user id while the value is the
            user features.
        items : dict, optional
            The starting items where the key is the user id while the value is the
            item features.
        ratings : dict, optional
            The starting ratings where the key is a double whose first index is the
            id of the user making the rating and the second index is the id of the item being
            rated. The value is a double whose first index is the rating value and the second
            index is a numpy array that represents the context in which the rating was made.

        &#34;&#34;&#34;
        self._users = []
        self._items = []
        self._ratings = scipy.sparse.dok_matrix((0, 0))
        self._rating_contexts = collections.defaultdict(list)
        self._outer_to_inner_uid = {}
        self._inner_to_outer_uid = []
        self._outer_to_inner_iid = {}
        self._inner_to_outer_iid = []
        self._dense_predictions = None
        self.update(users, items, ratings)

    def update(self, users=None, items=None, ratings=None):
        &#34;&#34;&#34;Update the recommender with new user, item, and rating data.

        Parameters
        ----------
        users : dict, optional
            The new users where the key is the user id while the value is the
            user features.
        items : dict, optional
            The new items where the key is the user id while the value is the
            item features.
        ratings : dict, optional
            The new ratings where the key is a double whose first index is the
            id of the user making the rating and the second index is the id of the item being
            rated. The value is a double whose first index is the rating value and the second
            index is a numpy array that represents the context in which the rating was made.

        &#34;&#34;&#34;
        self._dense_predictions = None

        # Update the user info.
        if users is not None:
            for user_id, features in users.items():
                if user_id not in self._outer_to_inner_uid:
                    self._outer_to_inner_uid[user_id] = len(self._users)
                    self._inner_to_outer_uid.append(user_id)
                    self._ratings.resize((self._ratings.shape[0] + 1, self._ratings.shape[1]))
                    self._users.append(features)
                else:
                    inner_id = self._outer_to_inner_uid[user_id]
                    self._users[inner_id] = features

        # Update the item info.
        if items is not None:
            for item_id, features in items.items():
                if item_id not in self._outer_to_inner_iid:
                    self._outer_to_inner_iid[item_id] = len(self._items)
                    self._inner_to_outer_iid.append(item_id)
                    self._ratings.resize((self._ratings.shape[0], self._ratings.shape[1] + 1))
                    self._items.append(features)
                else:
                    inner_id = self._outer_to_inner_iid[item_id]
                    self._items[inner_id] = features

        # Update the rating info.
        if ratings is not None:
            for (user_id, item_id), (rating, context) in ratings.items():
                inner_uid = self._outer_to_inner_uid[user_id]
                inner_iid = self._outer_to_inner_iid[item_id]
                self._ratings[inner_uid, inner_iid] = rating
                self._rating_contexts[inner_uid, inner_iid].append(context)
                assert inner_uid &lt; len(self._users)
                assert inner_iid &lt; len(self._items)

    def recommend(self, user_contexts, num_recommendations):
        &#34;&#34;&#34;Recommend items to users.

        Parameters
        ----------
        user_contexts : ordered dict
            The setting each user is going to be recommended items in. The key is the user id and
            the value is the rating features.
        num_recommendations : int
            The number of items to recommend to each user.

        Returns
        -------
        recs : list of list
            The recommendations made to each user. recs[i] is the list of item ids recommended
            to the i-th user.
        predicted_ratings : list of list
            The predicted ratings of the recommended items. recs[i] is the list of predicted
            ratings for the items recommended to the i-th user.

        &#34;&#34;&#34;
        # Format the arrays to be passed to the prediction function. We need to predict all
        # items that have not been rated for each user.
        ratings_to_predict = []
        all_item_ids = []
        # TODO: We need to figure out what to do when the number of items left to recommend
        # runs out.
        for user_id in user_contexts:
            inner_uid = self._outer_to_inner_uid[user_id]
            item_ids = self._ratings[inner_uid].nonzero()[1]
            item_ids = np.setdiff1d(np.arange(len(self._items)), item_ids)
            user_ids = inner_uid * np.ones(len(item_ids), dtype=np.int)
            contexts = len(item_ids) * [user_contexts[user_id]]
            ratings_to_predict += list(zip(user_ids, item_ids, contexts))
            all_item_ids.append(item_ids)

        # Predict the ratings and convert predictions into a list of arrays indexed by user.
        if self._dense_predictions is None:
            all_predictions = self._predict(ratings_to_predict)
        else:
            all_predictions = []
            for user_id, item_id, _ in ratings_to_predict:
                all_predictions.append(self._dense_predictions[user_id, item_id])

        item_lens = map(len, all_item_ids)
        all_predictions = np.split(all_predictions,
                                   list(itertools.accumulate(item_lens)))

        # Pick items according to the strategy, along with their predicted ratings.
        all_recs = []
        all_predicted_ratings = []
        # TODO: Right now items with the same ratings will be sorted in a deterministic order.
        # This probably shouldn&#39;t be the case.
        for item_ids, predictions in zip(all_item_ids, all_predictions):
            recs, predicted_ratings = self._select_item(item_ids, predictions,
                                                        num_recommendations)
            # Convert the recommendations to outer item ids.
            all_recs.append([self._inner_to_outer_iid[rec] for rec in recs])
            all_predicted_ratings.append(predicted_ratings)
        return np.array(all_recs), np.array(all_predicted_ratings)

    @property
    def dense_predictions(self):
        &#34;&#34;&#34;Get the predictions on all user-item pairs.

        This method should be overwritten if there is a more efficient way to compute dense
        predictions than calling _predict on all user-item pairs.
        &#34;&#34;&#34;
        if self._dense_predictions is None:
            user_item = []
            for i in range(len(self._users)):
                for j in range(len(self._items)):
                    user_item.append((i, j, np.zeros(0)))

            self._dense_predictions = self._predict(user_item)
            self._dense_predictions = self._dense_predictions.reshape((len(self._users),
                                                                       len(self._items)))
        return self._dense_predictions

    def predict(self, user_item):
        &#34;&#34;&#34;Predict the ratings of user-item pairs.

        Parameters
        ----------
        user_item : list of tuple
            The list of all user-item pairs along with the rating context.
            Each element is a triple where the first element in the tuple is
            the user id, the second element is the item id and the third element
            is the context in which the item will be rated.

        Returns
        -------
        predictions : np.ndarray
            The rating predictions where predictions[i] is the prediction of the i-th pair.

        &#34;&#34;&#34;
        inner_user_item = []
        for user_id, item_id, context in user_item:
            inner_uid = self._outer_to_inner_uid[user_id]
            inner_iid = self._outer_to_inner_iid[item_id]
            inner_user_item.append((inner_uid, inner_iid, context))
        return self._predict(inner_user_item)

    def _select_item(self, item_ids, predictions, num_recommendations):
        &#34;&#34;&#34;Select items given a strategy.

        Parameters
        ----------
        item_ids : np.ndarray of int
            ids of the items available for recommendation at this time step
        predictions : np.ndarray
            corresponding predicted ratings for these items
        num_recommendations : int
            number of items to select

        Returns
        -------
        recs : np.ndarray of int
            the indices of the items to be recommended
        predicted_ratings : np.ndarray
            predicted ratings for the selected items

        &#34;&#34;&#34;
        assert len(item_ids) == len(predictions)
        num_items = len(item_ids)
        strategy_name = self._strategy.split(&#39;,&#39;)[0]
        # TODO: clean up this method of parameter specification
        if len(self._strategy.split(&#39;,&#39;)) &gt; 1:
            strategy_param = self._strategy.split(&#39;,&#39;)[1]
        else:
            strategy_param = None
        if strategy_name == &#39;greedy&#39;:
            selected_indices = np.argsort(predictions)[-num_recommendations:]
        elif strategy_name == &#39;eps_greedy&#39;:
            if strategy_param is None:
                eps = 0.1
            else:
                eps = float(strategy_param)
            num_explore = np.random.binomial(num_recommendations, eps)
            num_exploit = num_recommendations - num_explore
            if num_exploit &gt; 0:
                exploit_indices = np.argsort(predictions)[-num_exploit:]
            else:
                exploit_indices = []
            explore_indices = np.random.choice([x for x in range(0, num_items)
                                                if x not in exploit_indices], num_explore)
            selected_indices = np.concatenate((exploit_indices, explore_indices))
        elif strategy_name == &#39;thompson&#39;:
            if strategy_param is None:
                # artificial parameter to boost the probability of the more likely items
                power = np.ceil(np.log(len(predictions)))
            else:
                power = int(float(strategy_param))
            selection_probs = np.power(predictions/sum(predictions), power)
            selection_probs = selection_probs/sum(selection_probs)
            selected_indices = np.random.choice(range(0, num_items),
                                                num_recommendations, p=selection_probs)
        selected_indices = selected_indices.astype(&#39;int&#39;)
        predicted_ratings = predictions[selected_indices]
        recs = item_ids[selected_indices]
        return recs, predicted_ratings

    @abc.abstractmethod
    def _predict(self, user_item):
        &#34;&#34;&#34;Predict the ratings of user-item pairs. This internal version assumes inner ids.

        Parameters
        ----------
        user_item : list of tuple
            The list of all user-item pairs along with the rating context.
            Each element is a triple where the first element in the tuple is
            the inner user id, the second element is the inner item id and the third element
            is the context in which the item will be rated.

        Returns
        -------
        predictions : np.ndarray
            The rating predictions where predictions[i] is the prediction of the i-th pair.

        &#34;&#34;&#34;
        raise NotImplementedError</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="reclab.recommenders.recommender.PredictRecommender"><code class="flex name class">
<span>class <span class="ident">PredictRecommender</span></span>
<span>(</span><span>strategy='greedy')</span>
</code></dt>
<dd>
<div class="desc"><p>A recommender that makes recommendations based on its rating predictions.</p>
<p>Data is primarily passed around through dicts for any recommenders derived from this class.
Each user is assumed to have a unique hashable id, likewise for all items. User and item
features as well as rating contexts are assumed to be dense arrays.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>strategy</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The item selection strategy to use.
Valid strategies are:
'greedy': chooses the unseen item with largest predicted rating
'eps_greedy': with probability 1-eps chooses the unseen item with largest
predicted rating, with probability eps chooses a random unseen item
'thompson': picks an item with probability proportional to the expected rating</dd>
</dl>
<p>Create a new PredictRecommender object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PredictRecommender(Recommender):
    &#34;&#34;&#34;A recommender that makes recommendations based on its rating predictions.

    Data is primarily passed around through dicts for any recommenders derived from this class.
    Each user is assumed to have a unique hashable id, likewise for all items. User and item
    features as well as rating contexts are assumed to be dense arrays.

    Parameters
    ----------
    strategy : str, optional
        The item selection strategy to use.
        Valid strategies are:
            &#39;greedy&#39;: chooses the unseen item with largest predicted rating
            &#39;eps_greedy&#39;: with probability 1-eps chooses the unseen item with largest
                           predicted rating, with probability eps chooses a random unseen item
            &#39;thompson&#39;: picks an item with probability proportional to the expected rating

    &#34;&#34;&#34;

    def __init__(self, strategy=&#39;greedy&#39;):
        &#34;&#34;&#34;Create a new PredictRecommender object.&#34;&#34;&#34;
        # The features associated with each user.
        self._users = []
        # The features associated with each item.
        self._items = []
        # The matrix of all numerical ratings.
        self._ratings = scipy.sparse.csr_matrix((0, 0))
        # Keeps track of the history of contexts in which a user-item rating was made.
        self._rating_contexts = collections.defaultdict(list)
        # Since outer ids passed to the recommender can be arbitrary hashable objects we
        # use these four variables to keep track of which index (AKA inner ids)
        # correspond to each outer id.
        self._outer_to_inner_uid = {}
        self._inner_to_outer_uid = []
        self._outer_to_inner_iid = {}
        self._inner_to_outer_iid = []
        # The sampling strategy to use.
        self._strategy = strategy
        # A dict of all the recommender&#39;s hyperparameters.
        self._hyperparameters = {&#39;strategy&#39;: strategy}
        # The cached dense predictions, reset to None each time update is called.
        self._dense_predictions = None
        # Check that the strategy is of valid type.
        assert self._strategy.split(&#39;,&#39;)[0] in [&#39;greedy&#39;, &#39;eps_greedy&#39;, &#39;thompson&#39;]

    @property
    def hyperparameters(self):
        &#34;&#34;&#34;Get a dict of all the recommender&#39;s hyperparameters.&#34;&#34;&#34;
        return self._hyperparameters

    def reset(self, users=None, items=None, ratings=None):
        &#34;&#34;&#34;Reset the recommender with optional starting user, item, and rating data.

        Parameters
        ----------
        users : dict, optional
            The starting users where the key is the user id while the value is the
            user features.
        items : dict, optional
            The starting items where the key is the user id while the value is the
            item features.
        ratings : dict, optional
            The starting ratings where the key is a double whose first index is the
            id of the user making the rating and the second index is the id of the item being
            rated. The value is a double whose first index is the rating value and the second
            index is a numpy array that represents the context in which the rating was made.

        &#34;&#34;&#34;
        self._users = []
        self._items = []
        self._ratings = scipy.sparse.dok_matrix((0, 0))
        self._rating_contexts = collections.defaultdict(list)
        self._outer_to_inner_uid = {}
        self._inner_to_outer_uid = []
        self._outer_to_inner_iid = {}
        self._inner_to_outer_iid = []
        self._dense_predictions = None
        self.update(users, items, ratings)

    def update(self, users=None, items=None, ratings=None):
        &#34;&#34;&#34;Update the recommender with new user, item, and rating data.

        Parameters
        ----------
        users : dict, optional
            The new users where the key is the user id while the value is the
            user features.
        items : dict, optional
            The new items where the key is the user id while the value is the
            item features.
        ratings : dict, optional
            The new ratings where the key is a double whose first index is the
            id of the user making the rating and the second index is the id of the item being
            rated. The value is a double whose first index is the rating value and the second
            index is a numpy array that represents the context in which the rating was made.

        &#34;&#34;&#34;
        self._dense_predictions = None

        # Update the user info.
        if users is not None:
            for user_id, features in users.items():
                if user_id not in self._outer_to_inner_uid:
                    self._outer_to_inner_uid[user_id] = len(self._users)
                    self._inner_to_outer_uid.append(user_id)
                    self._ratings.resize((self._ratings.shape[0] + 1, self._ratings.shape[1]))
                    self._users.append(features)
                else:
                    inner_id = self._outer_to_inner_uid[user_id]
                    self._users[inner_id] = features

        # Update the item info.
        if items is not None:
            for item_id, features in items.items():
                if item_id not in self._outer_to_inner_iid:
                    self._outer_to_inner_iid[item_id] = len(self._items)
                    self._inner_to_outer_iid.append(item_id)
                    self._ratings.resize((self._ratings.shape[0], self._ratings.shape[1] + 1))
                    self._items.append(features)
                else:
                    inner_id = self._outer_to_inner_iid[item_id]
                    self._items[inner_id] = features

        # Update the rating info.
        if ratings is not None:
            for (user_id, item_id), (rating, context) in ratings.items():
                inner_uid = self._outer_to_inner_uid[user_id]
                inner_iid = self._outer_to_inner_iid[item_id]
                self._ratings[inner_uid, inner_iid] = rating
                self._rating_contexts[inner_uid, inner_iid].append(context)
                assert inner_uid &lt; len(self._users)
                assert inner_iid &lt; len(self._items)

    def recommend(self, user_contexts, num_recommendations):
        &#34;&#34;&#34;Recommend items to users.

        Parameters
        ----------
        user_contexts : ordered dict
            The setting each user is going to be recommended items in. The key is the user id and
            the value is the rating features.
        num_recommendations : int
            The number of items to recommend to each user.

        Returns
        -------
        recs : list of list
            The recommendations made to each user. recs[i] is the list of item ids recommended
            to the i-th user.
        predicted_ratings : list of list
            The predicted ratings of the recommended items. recs[i] is the list of predicted
            ratings for the items recommended to the i-th user.

        &#34;&#34;&#34;
        # Format the arrays to be passed to the prediction function. We need to predict all
        # items that have not been rated for each user.
        ratings_to_predict = []
        all_item_ids = []
        # TODO: We need to figure out what to do when the number of items left to recommend
        # runs out.
        for user_id in user_contexts:
            inner_uid = self._outer_to_inner_uid[user_id]
            item_ids = self._ratings[inner_uid].nonzero()[1]
            item_ids = np.setdiff1d(np.arange(len(self._items)), item_ids)
            user_ids = inner_uid * np.ones(len(item_ids), dtype=np.int)
            contexts = len(item_ids) * [user_contexts[user_id]]
            ratings_to_predict += list(zip(user_ids, item_ids, contexts))
            all_item_ids.append(item_ids)

        # Predict the ratings and convert predictions into a list of arrays indexed by user.
        if self._dense_predictions is None:
            all_predictions = self._predict(ratings_to_predict)
        else:
            all_predictions = []
            for user_id, item_id, _ in ratings_to_predict:
                all_predictions.append(self._dense_predictions[user_id, item_id])

        item_lens = map(len, all_item_ids)
        all_predictions = np.split(all_predictions,
                                   list(itertools.accumulate(item_lens)))

        # Pick items according to the strategy, along with their predicted ratings.
        all_recs = []
        all_predicted_ratings = []
        # TODO: Right now items with the same ratings will be sorted in a deterministic order.
        # This probably shouldn&#39;t be the case.
        for item_ids, predictions in zip(all_item_ids, all_predictions):
            recs, predicted_ratings = self._select_item(item_ids, predictions,
                                                        num_recommendations)
            # Convert the recommendations to outer item ids.
            all_recs.append([self._inner_to_outer_iid[rec] for rec in recs])
            all_predicted_ratings.append(predicted_ratings)
        return np.array(all_recs), np.array(all_predicted_ratings)

    @property
    def dense_predictions(self):
        &#34;&#34;&#34;Get the predictions on all user-item pairs.

        This method should be overwritten if there is a more efficient way to compute dense
        predictions than calling _predict on all user-item pairs.
        &#34;&#34;&#34;
        if self._dense_predictions is None:
            user_item = []
            for i in range(len(self._users)):
                for j in range(len(self._items)):
                    user_item.append((i, j, np.zeros(0)))

            self._dense_predictions = self._predict(user_item)
            self._dense_predictions = self._dense_predictions.reshape((len(self._users),
                                                                       len(self._items)))
        return self._dense_predictions

    def predict(self, user_item):
        &#34;&#34;&#34;Predict the ratings of user-item pairs.

        Parameters
        ----------
        user_item : list of tuple
            The list of all user-item pairs along with the rating context.
            Each element is a triple where the first element in the tuple is
            the user id, the second element is the item id and the third element
            is the context in which the item will be rated.

        Returns
        -------
        predictions : np.ndarray
            The rating predictions where predictions[i] is the prediction of the i-th pair.

        &#34;&#34;&#34;
        inner_user_item = []
        for user_id, item_id, context in user_item:
            inner_uid = self._outer_to_inner_uid[user_id]
            inner_iid = self._outer_to_inner_iid[item_id]
            inner_user_item.append((inner_uid, inner_iid, context))
        return self._predict(inner_user_item)

    def _select_item(self, item_ids, predictions, num_recommendations):
        &#34;&#34;&#34;Select items given a strategy.

        Parameters
        ----------
        item_ids : np.ndarray of int
            ids of the items available for recommendation at this time step
        predictions : np.ndarray
            corresponding predicted ratings for these items
        num_recommendations : int
            number of items to select

        Returns
        -------
        recs : np.ndarray of int
            the indices of the items to be recommended
        predicted_ratings : np.ndarray
            predicted ratings for the selected items

        &#34;&#34;&#34;
        assert len(item_ids) == len(predictions)
        num_items = len(item_ids)
        strategy_name = self._strategy.split(&#39;,&#39;)[0]
        # TODO: clean up this method of parameter specification
        if len(self._strategy.split(&#39;,&#39;)) &gt; 1:
            strategy_param = self._strategy.split(&#39;,&#39;)[1]
        else:
            strategy_param = None
        if strategy_name == &#39;greedy&#39;:
            selected_indices = np.argsort(predictions)[-num_recommendations:]
        elif strategy_name == &#39;eps_greedy&#39;:
            if strategy_param is None:
                eps = 0.1
            else:
                eps = float(strategy_param)
            num_explore = np.random.binomial(num_recommendations, eps)
            num_exploit = num_recommendations - num_explore
            if num_exploit &gt; 0:
                exploit_indices = np.argsort(predictions)[-num_exploit:]
            else:
                exploit_indices = []
            explore_indices = np.random.choice([x for x in range(0, num_items)
                                                if x not in exploit_indices], num_explore)
            selected_indices = np.concatenate((exploit_indices, explore_indices))
        elif strategy_name == &#39;thompson&#39;:
            if strategy_param is None:
                # artificial parameter to boost the probability of the more likely items
                power = np.ceil(np.log(len(predictions)))
            else:
                power = int(float(strategy_param))
            selection_probs = np.power(predictions/sum(predictions), power)
            selection_probs = selection_probs/sum(selection_probs)
            selected_indices = np.random.choice(range(0, num_items),
                                                num_recommendations, p=selection_probs)
        selected_indices = selected_indices.astype(&#39;int&#39;)
        predicted_ratings = predictions[selected_indices]
        recs = item_ids[selected_indices]
        return recs, predicted_ratings

    @abc.abstractmethod
    def _predict(self, user_item):
        &#34;&#34;&#34;Predict the ratings of user-item pairs. This internal version assumes inner ids.

        Parameters
        ----------
        user_item : list of tuple
            The list of all user-item pairs along with the rating context.
            Each element is a triple where the first element in the tuple is
            the inner user id, the second element is the inner item id and the third element
            is the context in which the item will be rated.

        Returns
        -------
        predictions : np.ndarray
            The rating predictions where predictions[i] is the prediction of the i-th pair.

        &#34;&#34;&#34;
        raise NotImplementedError</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="reclab.recommenders.recommender.Recommender" href="#reclab.recommenders.recommender.Recommender">Recommender</a></li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="reclab.recommenders.autorec.autorec.Autorec" href="autorec/autorec.html#reclab.recommenders.autorec.autorec.Autorec">Autorec</a></li>
<li><a title="reclab.recommenders.baseline.PerfectRec" href="baseline.html#reclab.recommenders.baseline.PerfectRec">PerfectRec</a></li>
<li><a title="reclab.recommenders.baseline.RandomRec" href="baseline.html#reclab.recommenders.baseline.RandomRec">RandomRec</a></li>
<li><a title="reclab.recommenders.cfnade.cfnade.Cfnade" href="cfnade/cfnade.html#reclab.recommenders.cfnade.cfnade.Cfnade">Cfnade</a></li>
<li><a title="reclab.recommenders.knn_recommender.KNNRecommender" href="knn_recommender.html#reclab.recommenders.knn_recommender.KNNRecommender">KNNRecommender</a></li>
<li><a title="reclab.recommenders.libfm.LibFM" href="libfm.html#reclab.recommenders.libfm.LibFM">LibFM</a></li>
<li><a title="reclab.recommenders.llorma.llorma.Llorma" href="llorma/llorma.html#reclab.recommenders.llorma.llorma.Llorma">Llorma</a></li>
<li><a title="reclab.recommenders.sparse.EASE" href="sparse.html#reclab.recommenders.sparse.EASE">EASE</a></li>
<li><a title="reclab.recommenders.sparse.SLIM" href="sparse.html#reclab.recommenders.sparse.SLIM">SLIM</a></li>
<li><a title="reclab.recommenders.top_pop.TopPop" href="top_pop.html#reclab.recommenders.top_pop.TopPop">TopPop</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="reclab.recommenders.recommender.PredictRecommender.dense_predictions"><code class="name">var <span class="ident">dense_predictions</span></code></dt>
<dd>
<div class="desc"><p>Get the predictions on all user-item pairs.</p>
<p>This method should be overwritten if there is a more efficient way to compute dense
predictions than calling _predict on all user-item pairs.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def dense_predictions(self):
    &#34;&#34;&#34;Get the predictions on all user-item pairs.

    This method should be overwritten if there is a more efficient way to compute dense
    predictions than calling _predict on all user-item pairs.
    &#34;&#34;&#34;
    if self._dense_predictions is None:
        user_item = []
        for i in range(len(self._users)):
            for j in range(len(self._items)):
                user_item.append((i, j, np.zeros(0)))

        self._dense_predictions = self._predict(user_item)
        self._dense_predictions = self._dense_predictions.reshape((len(self._users),
                                                                   len(self._items)))
    return self._dense_predictions</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="reclab.recommenders.recommender.PredictRecommender.predict"><code class="name flex">
<span>def <span class="ident">predict</span></span>(<span>self, user_item)</span>
</code></dt>
<dd>
<div class="desc"><p>Predict the ratings of user-item pairs.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>user_item</code></strong> :&ensp;<code>list</code> of <code>tuple</code></dt>
<dd>The list of all user-item pairs along with the rating context.
Each element is a triple where the first element in the tuple is
the user id, the second element is the item id and the third element
is the context in which the item will be rated.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>predictions</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>The rating predictions where predictions[i] is the prediction of the i-th pair.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def predict(self, user_item):
    &#34;&#34;&#34;Predict the ratings of user-item pairs.

    Parameters
    ----------
    user_item : list of tuple
        The list of all user-item pairs along with the rating context.
        Each element is a triple where the first element in the tuple is
        the user id, the second element is the item id and the third element
        is the context in which the item will be rated.

    Returns
    -------
    predictions : np.ndarray
        The rating predictions where predictions[i] is the prediction of the i-th pair.

    &#34;&#34;&#34;
    inner_user_item = []
    for user_id, item_id, context in user_item:
        inner_uid = self._outer_to_inner_uid[user_id]
        inner_iid = self._outer_to_inner_iid[item_id]
        inner_user_item.append((inner_uid, inner_iid, context))
    return self._predict(inner_user_item)</code></pre>
</details>
</dd>
<dt id="reclab.recommenders.recommender.PredictRecommender.recommend"><code class="name flex">
<span>def <span class="ident">recommend</span></span>(<span>self, user_contexts, num_recommendations)</span>
</code></dt>
<dd>
<div class="desc"><p>Recommend items to users.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>user_contexts</code></strong> :&ensp;<code>ordered dict</code></dt>
<dd>The setting each user is going to be recommended items in. The key is the user id and
the value is the rating features.</dd>
<dt><strong><code>num_recommendations</code></strong> :&ensp;<code>int</code></dt>
<dd>The number of items to recommend to each user.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>recs</code></strong> :&ensp;<code>list</code> of <code>list</code></dt>
<dd>The recommendations made to each user. recs[i] is the list of item ids recommended
to the i-th user.</dd>
<dt><strong><code>predicted_ratings</code></strong> :&ensp;<code>list</code> of <code>list</code></dt>
<dd>The predicted ratings of the recommended items. recs[i] is the list of predicted
ratings for the items recommended to the i-th user.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def recommend(self, user_contexts, num_recommendations):
    &#34;&#34;&#34;Recommend items to users.

    Parameters
    ----------
    user_contexts : ordered dict
        The setting each user is going to be recommended items in. The key is the user id and
        the value is the rating features.
    num_recommendations : int
        The number of items to recommend to each user.

    Returns
    -------
    recs : list of list
        The recommendations made to each user. recs[i] is the list of item ids recommended
        to the i-th user.
    predicted_ratings : list of list
        The predicted ratings of the recommended items. recs[i] is the list of predicted
        ratings for the items recommended to the i-th user.

    &#34;&#34;&#34;
    # Format the arrays to be passed to the prediction function. We need to predict all
    # items that have not been rated for each user.
    ratings_to_predict = []
    all_item_ids = []
    # TODO: We need to figure out what to do when the number of items left to recommend
    # runs out.
    for user_id in user_contexts:
        inner_uid = self._outer_to_inner_uid[user_id]
        item_ids = self._ratings[inner_uid].nonzero()[1]
        item_ids = np.setdiff1d(np.arange(len(self._items)), item_ids)
        user_ids = inner_uid * np.ones(len(item_ids), dtype=np.int)
        contexts = len(item_ids) * [user_contexts[user_id]]
        ratings_to_predict += list(zip(user_ids, item_ids, contexts))
        all_item_ids.append(item_ids)

    # Predict the ratings and convert predictions into a list of arrays indexed by user.
    if self._dense_predictions is None:
        all_predictions = self._predict(ratings_to_predict)
    else:
        all_predictions = []
        for user_id, item_id, _ in ratings_to_predict:
            all_predictions.append(self._dense_predictions[user_id, item_id])

    item_lens = map(len, all_item_ids)
    all_predictions = np.split(all_predictions,
                               list(itertools.accumulate(item_lens)))

    # Pick items according to the strategy, along with their predicted ratings.
    all_recs = []
    all_predicted_ratings = []
    # TODO: Right now items with the same ratings will be sorted in a deterministic order.
    # This probably shouldn&#39;t be the case.
    for item_ids, predictions in zip(all_item_ids, all_predictions):
        recs, predicted_ratings = self._select_item(item_ids, predictions,
                                                    num_recommendations)
        # Convert the recommendations to outer item ids.
        all_recs.append([self._inner_to_outer_iid[rec] for rec in recs])
        all_predicted_ratings.append(predicted_ratings)
    return np.array(all_recs), np.array(all_predicted_ratings)</code></pre>
</details>
</dd>
<dt id="reclab.recommenders.recommender.PredictRecommender.reset"><code class="name flex">
<span>def <span class="ident">reset</span></span>(<span>self, users=None, items=None, ratings=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Reset the recommender with optional starting user, item, and rating data.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>users</code></strong> :&ensp;<code>dict</code>, optional</dt>
<dd>The starting users where the key is the user id while the value is the
user features.</dd>
<dt><strong><code>items</code></strong> :&ensp;<code>dict</code>, optional</dt>
<dd>The starting items where the key is the user id while the value is the
item features.</dd>
<dt><strong><code>ratings</code></strong> :&ensp;<code>dict</code>, optional</dt>
<dd>The starting ratings where the key is a double whose first index is the
id of the user making the rating and the second index is the id of the item being
rated. The value is a double whose first index is the rating value and the second
index is a numpy array that represents the context in which the rating was made.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reset(self, users=None, items=None, ratings=None):
    &#34;&#34;&#34;Reset the recommender with optional starting user, item, and rating data.

    Parameters
    ----------
    users : dict, optional
        The starting users where the key is the user id while the value is the
        user features.
    items : dict, optional
        The starting items where the key is the user id while the value is the
        item features.
    ratings : dict, optional
        The starting ratings where the key is a double whose first index is the
        id of the user making the rating and the second index is the id of the item being
        rated. The value is a double whose first index is the rating value and the second
        index is a numpy array that represents the context in which the rating was made.

    &#34;&#34;&#34;
    self._users = []
    self._items = []
    self._ratings = scipy.sparse.dok_matrix((0, 0))
    self._rating_contexts = collections.defaultdict(list)
    self._outer_to_inner_uid = {}
    self._inner_to_outer_uid = []
    self._outer_to_inner_iid = {}
    self._inner_to_outer_iid = []
    self._dense_predictions = None
    self.update(users, items, ratings)</code></pre>
</details>
</dd>
<dt id="reclab.recommenders.recommender.PredictRecommender.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self, users=None, items=None, ratings=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Update the recommender with new user, item, and rating data.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>users</code></strong> :&ensp;<code>dict</code>, optional</dt>
<dd>The new users where the key is the user id while the value is the
user features.</dd>
<dt><strong><code>items</code></strong> :&ensp;<code>dict</code>, optional</dt>
<dd>The new items where the key is the user id while the value is the
item features.</dd>
<dt><strong><code>ratings</code></strong> :&ensp;<code>dict</code>, optional</dt>
<dd>The new ratings where the key is a double whose first index is the
id of the user making the rating and the second index is the id of the item being
rated. The value is a double whose first index is the rating value and the second
index is a numpy array that represents the context in which the rating was made.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update(self, users=None, items=None, ratings=None):
    &#34;&#34;&#34;Update the recommender with new user, item, and rating data.

    Parameters
    ----------
    users : dict, optional
        The new users where the key is the user id while the value is the
        user features.
    items : dict, optional
        The new items where the key is the user id while the value is the
        item features.
    ratings : dict, optional
        The new ratings where the key is a double whose first index is the
        id of the user making the rating and the second index is the id of the item being
        rated. The value is a double whose first index is the rating value and the second
        index is a numpy array that represents the context in which the rating was made.

    &#34;&#34;&#34;
    self._dense_predictions = None

    # Update the user info.
    if users is not None:
        for user_id, features in users.items():
            if user_id not in self._outer_to_inner_uid:
                self._outer_to_inner_uid[user_id] = len(self._users)
                self._inner_to_outer_uid.append(user_id)
                self._ratings.resize((self._ratings.shape[0] + 1, self._ratings.shape[1]))
                self._users.append(features)
            else:
                inner_id = self._outer_to_inner_uid[user_id]
                self._users[inner_id] = features

    # Update the item info.
    if items is not None:
        for item_id, features in items.items():
            if item_id not in self._outer_to_inner_iid:
                self._outer_to_inner_iid[item_id] = len(self._items)
                self._inner_to_outer_iid.append(item_id)
                self._ratings.resize((self._ratings.shape[0], self._ratings.shape[1] + 1))
                self._items.append(features)
            else:
                inner_id = self._outer_to_inner_iid[item_id]
                self._items[inner_id] = features

    # Update the rating info.
    if ratings is not None:
        for (user_id, item_id), (rating, context) in ratings.items():
            inner_uid = self._outer_to_inner_uid[user_id]
            inner_iid = self._outer_to_inner_iid[item_id]
            self._ratings[inner_uid, inner_iid] = rating
            self._rating_contexts[inner_uid, inner_iid].append(context)
            assert inner_uid &lt; len(self._users)
            assert inner_iid &lt; len(self._items)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="reclab.recommenders.recommender.Recommender" href="#reclab.recommenders.recommender.Recommender">Recommender</a></b></code>:
<ul class="hlist">
<li><code><a title="reclab.recommenders.recommender.Recommender.hyperparameters" href="#reclab.recommenders.recommender.Recommender.hyperparameters">hyperparameters</a></code></li>
<li><code><a title="reclab.recommenders.recommender.Recommender.name" href="#reclab.recommenders.recommender.Recommender.name">name</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="reclab.recommenders.recommender.Recommender"><code class="flex name class">
<span>class <span class="ident">Recommender</span></span>
</code></dt>
<dd>
<div class="desc"><p>The interface for recommenders.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Recommender(abc.ABC):
    &#34;&#34;&#34;The interface for recommenders.&#34;&#34;&#34;

    @property
    @abc.abstractmethod
    def name(self):
        &#34;&#34;&#34;Get the name of the recommender.&#34;&#34;&#34;
        raise NotImplementedError

    @property
    @abc.abstractmethod
    def hyperparameters(self):
        &#34;&#34;&#34;Get a dict of all the recommender&#39;s hyperparameters.&#34;&#34;&#34;
        raise NotImplementedError

    @abc.abstractmethod
    def reset(self, users=None, items=None, ratings=None):
        &#34;&#34;&#34;Reset the recommender with optional starting user, item, and rating data.

        Parameters
        ----------
        users : iterable, optional
            The starting users.
        items : iterable, optional
            The starting items.
        ratings : iterable, optional
            The starting ratings and the associated contexts in which each rating was made.

        &#34;&#34;&#34;
        raise NotImplementedError

    @abc.abstractmethod
    def update(self, users=None, items=None, ratings=None):
        &#34;&#34;&#34;Update the recommender with new user, item, and rating data.

        Parameters
        ----------
        users : iterable, optional
            The new users.
        items : iterable, optional
            The new items.
        ratings : iterable, optional
            The new ratings and the associated context in which each rating was made.

        &#34;&#34;&#34;
        raise NotImplementedError

    @abc.abstractmethod
    def recommend(self, user_contexts, num_recommendations):
        &#34;&#34;&#34;Recommend items to users.

        Parameters
        ----------
        user_contexts : iterable
            The setting each user is going to be recommended items in.
        num_recommendations : int
            The number of items to recommend to each user.

        Returns
        -------
        recs : iterable
            The recommendations made to each user. recs[i] represents the recommendations
            made to the i-th user in the user_contexts variable.
        predicted_ratings : iterable or None
            The predicted rating for each item recommended to each user. Where predicted_ratings[i]
            represents the predictions of recommended items on the i-th user in the user_contexts
            variable. Derived classes may simply return None if they do not directly estimate
            ratings when making recommendations.

        &#34;&#34;&#34;
        raise NotImplementedError</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="reclab.recommenders.recommender.PredictRecommender" href="#reclab.recommenders.recommender.PredictRecommender">PredictRecommender</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="reclab.recommenders.recommender.Recommender.hyperparameters"><code class="name">var <span class="ident">hyperparameters</span></code></dt>
<dd>
<div class="desc"><p>Get a dict of all the recommender's hyperparameters.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
@abc.abstractmethod
def hyperparameters(self):
    &#34;&#34;&#34;Get a dict of all the recommender&#39;s hyperparameters.&#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="reclab.recommenders.recommender.Recommender.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"><p>Get the name of the recommender.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
@abc.abstractmethod
def name(self):
    &#34;&#34;&#34;Get the name of the recommender.&#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="reclab.recommenders.recommender.Recommender.recommend"><code class="name flex">
<span>def <span class="ident">recommend</span></span>(<span>self, user_contexts, num_recommendations)</span>
</code></dt>
<dd>
<div class="desc"><p>Recommend items to users.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>user_contexts</code></strong> :&ensp;<code>iterable</code></dt>
<dd>The setting each user is going to be recommended items in.</dd>
<dt><strong><code>num_recommendations</code></strong> :&ensp;<code>int</code></dt>
<dd>The number of items to recommend to each user.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>recs</code></strong> :&ensp;<code>iterable</code></dt>
<dd>The recommendations made to each user. recs[i] represents the recommendations
made to the i-th user in the user_contexts variable.</dd>
<dt><strong><code>predicted_ratings</code></strong> :&ensp;<code>iterable</code> or <code>None</code></dt>
<dd>The predicted rating for each item recommended to each user. Where predicted_ratings[i]
represents the predictions of recommended items on the i-th user in the user_contexts
variable. Derived classes may simply return None if they do not directly estimate
ratings when making recommendations.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractmethod
def recommend(self, user_contexts, num_recommendations):
    &#34;&#34;&#34;Recommend items to users.

    Parameters
    ----------
    user_contexts : iterable
        The setting each user is going to be recommended items in.
    num_recommendations : int
        The number of items to recommend to each user.

    Returns
    -------
    recs : iterable
        The recommendations made to each user. recs[i] represents the recommendations
        made to the i-th user in the user_contexts variable.
    predicted_ratings : iterable or None
        The predicted rating for each item recommended to each user. Where predicted_ratings[i]
        represents the predictions of recommended items on the i-th user in the user_contexts
        variable. Derived classes may simply return None if they do not directly estimate
        ratings when making recommendations.

    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="reclab.recommenders.recommender.Recommender.reset"><code class="name flex">
<span>def <span class="ident">reset</span></span>(<span>self, users=None, items=None, ratings=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Reset the recommender with optional starting user, item, and rating data.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>users</code></strong> :&ensp;<code>iterable</code>, optional</dt>
<dd>The starting users.</dd>
<dt><strong><code>items</code></strong> :&ensp;<code>iterable</code>, optional</dt>
<dd>The starting items.</dd>
<dt><strong><code>ratings</code></strong> :&ensp;<code>iterable</code>, optional</dt>
<dd>The starting ratings and the associated contexts in which each rating was made.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractmethod
def reset(self, users=None, items=None, ratings=None):
    &#34;&#34;&#34;Reset the recommender with optional starting user, item, and rating data.

    Parameters
    ----------
    users : iterable, optional
        The starting users.
    items : iterable, optional
        The starting items.
    ratings : iterable, optional
        The starting ratings and the associated contexts in which each rating was made.

    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="reclab.recommenders.recommender.Recommender.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self, users=None, items=None, ratings=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Update the recommender with new user, item, and rating data.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>users</code></strong> :&ensp;<code>iterable</code>, optional</dt>
<dd>The new users.</dd>
<dt><strong><code>items</code></strong> :&ensp;<code>iterable</code>, optional</dt>
<dd>The new items.</dd>
<dt><strong><code>ratings</code></strong> :&ensp;<code>iterable</code>, optional</dt>
<dd>The new ratings and the associated context in which each rating was made.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractmethod
def update(self, users=None, items=None, ratings=None):
    &#34;&#34;&#34;Update the recommender with new user, item, and rating data.

    Parameters
    ----------
    users : iterable, optional
        The new users.
    items : iterable, optional
        The new items.
    ratings : iterable, optional
        The new ratings and the associated context in which each rating was made.

    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="reclab.recommenders" href="index.html">reclab.recommenders</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="reclab.recommenders.recommender.PredictRecommender" href="#reclab.recommenders.recommender.PredictRecommender">PredictRecommender</a></code></h4>
<ul class="">
<li><code><a title="reclab.recommenders.recommender.PredictRecommender.dense_predictions" href="#reclab.recommenders.recommender.PredictRecommender.dense_predictions">dense_predictions</a></code></li>
<li><code><a title="reclab.recommenders.recommender.PredictRecommender.predict" href="#reclab.recommenders.recommender.PredictRecommender.predict">predict</a></code></li>
<li><code><a title="reclab.recommenders.recommender.PredictRecommender.recommend" href="#reclab.recommenders.recommender.PredictRecommender.recommend">recommend</a></code></li>
<li><code><a title="reclab.recommenders.recommender.PredictRecommender.reset" href="#reclab.recommenders.recommender.PredictRecommender.reset">reset</a></code></li>
<li><code><a title="reclab.recommenders.recommender.PredictRecommender.update" href="#reclab.recommenders.recommender.PredictRecommender.update">update</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="reclab.recommenders.recommender.Recommender" href="#reclab.recommenders.recommender.Recommender">Recommender</a></code></h4>
<ul class="">
<li><code><a title="reclab.recommenders.recommender.Recommender.hyperparameters" href="#reclab.recommenders.recommender.Recommender.hyperparameters">hyperparameters</a></code></li>
<li><code><a title="reclab.recommenders.recommender.Recommender.name" href="#reclab.recommenders.recommender.Recommender.name">name</a></code></li>
<li><code><a title="reclab.recommenders.recommender.Recommender.recommend" href="#reclab.recommenders.recommender.Recommender.recommend">recommend</a></code></li>
<li><code><a title="reclab.recommenders.recommender.Recommender.reset" href="#reclab.recommenders.recommender.Recommender.reset">reset</a></code></li>
<li><code><a title="reclab.recommenders.recommender.Recommender.update" href="#reclab.recommenders.recommender.Recommender.update">update</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.4</a>.</p>
</footer>
</body>
</html>