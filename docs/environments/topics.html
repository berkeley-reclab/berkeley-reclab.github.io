<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.4" />
<title>reclab.environments.topics API documentation</title>
<meta name="description" content="Contains the implementation for the Topics environment â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/highlight.min.js" integrity="sha256-eOgo0OtLL4cdq7RdwRUiGKLX9XsIJ7nGhWEKbohmVAQ=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>reclab.environments.topics</code></h1>
</header>
<section id="section-intro">
<p>Contains the implementation for the Topics environment.</p>
<p>In this environment users have a hidden preference for each topic and each item has a
hidden topic assigned to it.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Contains the implementation for the Topics environment.

In this environment users have a hidden preference for each topic and each item has a
hidden topic assigned to it.
&#34;&#34;&#34;
import collections
import numpy as np

from . import environment


class Topics(environment.DictEnvironment):
    &#34;&#34;&#34;An environment where items have a single topic and users prefer certain topics.

    The user preference for any given topic is initialized as Unif(0.5, 5.5) while
    topics are uniformly assigned to items. Users will rate items as clip(p + e, 0, 5)
    where p is their preference for a given topic and e ~ N(0, self._noise). Users will
    also have a changing preference for topics they get recommended based on the topic_change
    parameter.

    Parameters
    ----------
    num_topics : int
        The number of topics items can be assigned to.
    num_users : int
        The number of users in the environment.
    num_items : int
        The number of items in the environment.
    rating_frequency : float
        The proportion of users that will need a recommendation at each step.
        Must be between 0 and 1.
    num_init_ratings : int
        The number of ratings available from the start. User-item pairs are randomly selected.
    noise : float
        The standard deviation of the noise added to ratings.
    topic_change : float
        How much the user&#39;s preference for a topic changes each time that topic is recommended
        to them. The negative of topic_change gets split across all other topics as well.
    memory_length : int
        The number of recent topics a user remembers which affect the rating
    boredom_threshold : int
        The number of times a topics has to be seen within the memory to gain a
        penalty.
    boredom_penalty : float
        The penalty on the rating when a user is bored
    user_dist_choice : str
        The choice of user distribution for selecting online users. By default, the subset of
        online users is chosen from a uniform distribution. Currently supports normal and lognormal.
    shift_steps : int
        The number of timesteps to wait between each user preference shift.
    shift_frequency : float
        The proportion of users whose preference we wish to change during a preference shift.
    shift_weight : float
        The weight to assign to a user&#39;s new preferences after a preference shift.
        User&#39;s old preferences get assigned a weight of 1 - shift_weight.

    &#34;&#34;&#34;

    def __init__(self,
                 num_topics,
                 num_users,
                 num_items,
                 rating_frequency=1.0,
                 num_init_ratings=0,
                 noise=0.0,
                 topic_change=0.0,
                 memory_length=0,
                 boredom_threshold=0,
                 boredom_penalty=0.0,
                 user_dist_choice=&#39;uniform&#39;,
                 shift_steps=1,
                 shift_frequency=0.0,
                 shift_weight=0.0):
        &#34;&#34;&#34;Create a Topics environment.&#34;&#34;&#34;
        super().__init__(rating_frequency, num_init_ratings, memory_length, user_dist_choice)
        self._num_topics = num_topics
        self._num_users = num_users
        self._num_items = num_items
        self._topic_change = topic_change
        self._noise = noise
        self._user_preferences = None
        self._item_topics = None
        self._boredom_threshold = boredom_threshold
        self._boredom_penalty = boredom_penalty
        self._shift_steps = shift_steps
        self._shift_frequency = shift_frequency
        self._shift_weight = shift_weight

    @property
    def name(self):  # noqa: D102
        return &#39;topics&#39;

    def _get_dense_ratings(self):  # noqa: D102
        ratings = np.zeros([self._num_users, self._num_items])
        for item_id in range(self._num_items):
            topic = self._item_topics[item_id]
            ratings[:, item_id] = self._user_preferences[:, topic]

        # Account for boredom.
        for user_id in range(self._num_users):
            recent_topics = [self._item_topics[item] for item in self._user_histories[user_id]]
            recent_topics, counts = np.unique(recent_topics, return_counts=True)
            recent_topics = recent_topics[counts &gt; self._boredom_threshold]
            for topic_id in recent_topics:
                ratings[user_id, self._item_topics == topic_id] -= self._boredom_penalty

        return ratings

    def _get_rating(self, user_id, item_id):  # noqa: D102
        topic = self._item_topics[item_id]
        rating = self._user_preferences[user_id, topic]
        recent_topics = [self._item_topics[item] for item in self._user_histories[user_id]]
        if recent_topics.count(topic) &gt; self._boredom_threshold:
            rating -= self._boredom_penalty
        rating = np.clip(rating + self._dynamics_random.randn() * self._noise, 1, 5)
        return rating

    def _rate_item(self, user_id, item_id):  # noqa: D102
        rating = self._get_rating(user_id, item_id)
        # Updating underlying preference
        topic = self._item_topics[item_id]
        preference = self._user_preferences[user_id, topic]
        if preference &lt;= 5:
            self._user_preferences[user_id, topic] += self._topic_change
            not_topic = np.arange(self._num_topics) != topic
            self._user_preferences[user_id, not_topic] -= (
                self._topic_change / (self._num_topics - 1))
        return rating

    def _reset_state(self):  # noqa: D102
        self._user_preferences = self._init_random.uniform(low=0.5, high=5.5,
                                                           size=(self._num_users, self._num_topics))
        self._item_topics = self._init_random.choice(self._num_topics, size=self._num_items)
        self._users = collections.OrderedDict((user_id, np.zeros(0))
                                              for user_id in range(self._num_users))
        self._items = collections.OrderedDict((item_id, np.zeros(0))
                                              for item_id in range(self._num_items))

    def _update_state(self):  # noqa: D102
        if self._timestep % self._shift_steps == 0:
            # Apply the preference shift to a fraction of users.
            shifted_users = self._dynamics_random.choice(
                self._num_users, int(self._num_users * self._shift_frequency))

            new_preferences = self._init_random.uniform(low=0.5, high=5.5,
                                                        size=(len(shifted_users), self._num_topics))
            self._user_preferences[shifted_users] = (
                self._shift_weight * self._user_preferences[shifted_users] +
                (1 - self._shift_weight) * new_preferences)

        return collections.OrderedDict(), collections.OrderedDict()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="reclab.environments.topics.Topics"><code class="flex name class">
<span>class <span class="ident">Topics</span></span>
<span>(</span><span>num_topics, num_users, num_items, rating_frequency=1.0, num_init_ratings=0, noise=0.0, topic_change=0.0, memory_length=0, boredom_threshold=0, boredom_penalty=0.0, user_dist_choice='uniform', shift_steps=1, shift_frequency=0.0, shift_weight=0.0)</span>
</code></dt>
<dd>
<div class="desc"><p>An environment where items have a single topic and users prefer certain topics.</p>
<p>The user preference for any given topic is initialized as Unif(0.5, 5.5) while
topics are uniformly assigned to items. Users will rate items as clip(p + e, 0, 5)
where p is their preference for a given topic and e ~ N(0, self._noise). Users will
also have a changing preference for topics they get recommended based on the topic_change
parameter.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>num_topics</code></strong> :&ensp;<code>int</code></dt>
<dd>The number of topics items can be assigned to.</dd>
<dt><strong><code>num_users</code></strong> :&ensp;<code>int</code></dt>
<dd>The number of users in the environment.</dd>
<dt><strong><code>num_items</code></strong> :&ensp;<code>int</code></dt>
<dd>The number of items in the environment.</dd>
<dt><strong><code>rating_frequency</code></strong> :&ensp;<code>float</code></dt>
<dd>The proportion of users that will need a recommendation at each step.
Must be between 0 and 1.</dd>
<dt><strong><code>num_init_ratings</code></strong> :&ensp;<code>int</code></dt>
<dd>The number of ratings available from the start. User-item pairs are randomly selected.</dd>
<dt><strong><code>noise</code></strong> :&ensp;<code>float</code></dt>
<dd>The standard deviation of the noise added to ratings.</dd>
<dt><strong><code>topic_change</code></strong> :&ensp;<code>float</code></dt>
<dd>How much the user's preference for a topic changes each time that topic is recommended
to them. The negative of topic_change gets split across all other topics as well.</dd>
<dt><strong><code>memory_length</code></strong> :&ensp;<code>int</code></dt>
<dd>The number of recent topics a user remembers which affect the rating</dd>
<dt><strong><code>boredom_threshold</code></strong> :&ensp;<code>int</code></dt>
<dd>The number of times a topics has to be seen within the memory to gain a
penalty.</dd>
<dt><strong><code>boredom_penalty</code></strong> :&ensp;<code>float</code></dt>
<dd>The penalty on the rating when a user is bored</dd>
<dt><strong><code>user_dist_choice</code></strong> :&ensp;<code>str</code></dt>
<dd>The choice of user distribution for selecting online users. By default, the subset of
online users is chosen from a uniform distribution. Currently supports normal and lognormal.</dd>
<dt><strong><code>shift_steps</code></strong> :&ensp;<code>int</code></dt>
<dd>The number of timesteps to wait between each user preference shift.</dd>
<dt><strong><code>shift_frequency</code></strong> :&ensp;<code>float</code></dt>
<dd>The proportion of users whose preference we wish to change during a preference shift.</dd>
<dt><strong><code>shift_weight</code></strong> :&ensp;<code>float</code></dt>
<dd>The weight to assign to a user's new preferences after a preference shift.
User's old preferences get assigned a weight of 1 - shift_weight.</dd>
</dl>
<p>Create a Topics environment.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Topics(environment.DictEnvironment):
    &#34;&#34;&#34;An environment where items have a single topic and users prefer certain topics.

    The user preference for any given topic is initialized as Unif(0.5, 5.5) while
    topics are uniformly assigned to items. Users will rate items as clip(p + e, 0, 5)
    where p is their preference for a given topic and e ~ N(0, self._noise). Users will
    also have a changing preference for topics they get recommended based on the topic_change
    parameter.

    Parameters
    ----------
    num_topics : int
        The number of topics items can be assigned to.
    num_users : int
        The number of users in the environment.
    num_items : int
        The number of items in the environment.
    rating_frequency : float
        The proportion of users that will need a recommendation at each step.
        Must be between 0 and 1.
    num_init_ratings : int
        The number of ratings available from the start. User-item pairs are randomly selected.
    noise : float
        The standard deviation of the noise added to ratings.
    topic_change : float
        How much the user&#39;s preference for a topic changes each time that topic is recommended
        to them. The negative of topic_change gets split across all other topics as well.
    memory_length : int
        The number of recent topics a user remembers which affect the rating
    boredom_threshold : int
        The number of times a topics has to be seen within the memory to gain a
        penalty.
    boredom_penalty : float
        The penalty on the rating when a user is bored
    user_dist_choice : str
        The choice of user distribution for selecting online users. By default, the subset of
        online users is chosen from a uniform distribution. Currently supports normal and lognormal.
    shift_steps : int
        The number of timesteps to wait between each user preference shift.
    shift_frequency : float
        The proportion of users whose preference we wish to change during a preference shift.
    shift_weight : float
        The weight to assign to a user&#39;s new preferences after a preference shift.
        User&#39;s old preferences get assigned a weight of 1 - shift_weight.

    &#34;&#34;&#34;

    def __init__(self,
                 num_topics,
                 num_users,
                 num_items,
                 rating_frequency=1.0,
                 num_init_ratings=0,
                 noise=0.0,
                 topic_change=0.0,
                 memory_length=0,
                 boredom_threshold=0,
                 boredom_penalty=0.0,
                 user_dist_choice=&#39;uniform&#39;,
                 shift_steps=1,
                 shift_frequency=0.0,
                 shift_weight=0.0):
        &#34;&#34;&#34;Create a Topics environment.&#34;&#34;&#34;
        super().__init__(rating_frequency, num_init_ratings, memory_length, user_dist_choice)
        self._num_topics = num_topics
        self._num_users = num_users
        self._num_items = num_items
        self._topic_change = topic_change
        self._noise = noise
        self._user_preferences = None
        self._item_topics = None
        self._boredom_threshold = boredom_threshold
        self._boredom_penalty = boredom_penalty
        self._shift_steps = shift_steps
        self._shift_frequency = shift_frequency
        self._shift_weight = shift_weight

    @property
    def name(self):  # noqa: D102
        return &#39;topics&#39;

    def _get_dense_ratings(self):  # noqa: D102
        ratings = np.zeros([self._num_users, self._num_items])
        for item_id in range(self._num_items):
            topic = self._item_topics[item_id]
            ratings[:, item_id] = self._user_preferences[:, topic]

        # Account for boredom.
        for user_id in range(self._num_users):
            recent_topics = [self._item_topics[item] for item in self._user_histories[user_id]]
            recent_topics, counts = np.unique(recent_topics, return_counts=True)
            recent_topics = recent_topics[counts &gt; self._boredom_threshold]
            for topic_id in recent_topics:
                ratings[user_id, self._item_topics == topic_id] -= self._boredom_penalty

        return ratings

    def _get_rating(self, user_id, item_id):  # noqa: D102
        topic = self._item_topics[item_id]
        rating = self._user_preferences[user_id, topic]
        recent_topics = [self._item_topics[item] for item in self._user_histories[user_id]]
        if recent_topics.count(topic) &gt; self._boredom_threshold:
            rating -= self._boredom_penalty
        rating = np.clip(rating + self._dynamics_random.randn() * self._noise, 1, 5)
        return rating

    def _rate_item(self, user_id, item_id):  # noqa: D102
        rating = self._get_rating(user_id, item_id)
        # Updating underlying preference
        topic = self._item_topics[item_id]
        preference = self._user_preferences[user_id, topic]
        if preference &lt;= 5:
            self._user_preferences[user_id, topic] += self._topic_change
            not_topic = np.arange(self._num_topics) != topic
            self._user_preferences[user_id, not_topic] -= (
                self._topic_change / (self._num_topics - 1))
        return rating

    def _reset_state(self):  # noqa: D102
        self._user_preferences = self._init_random.uniform(low=0.5, high=5.5,
                                                           size=(self._num_users, self._num_topics))
        self._item_topics = self._init_random.choice(self._num_topics, size=self._num_items)
        self._users = collections.OrderedDict((user_id, np.zeros(0))
                                              for user_id in range(self._num_users))
        self._items = collections.OrderedDict((item_id, np.zeros(0))
                                              for item_id in range(self._num_items))

    def _update_state(self):  # noqa: D102
        if self._timestep % self._shift_steps == 0:
            # Apply the preference shift to a fraction of users.
            shifted_users = self._dynamics_random.choice(
                self._num_users, int(self._num_users * self._shift_frequency))

            new_preferences = self._init_random.uniform(low=0.5, high=5.5,
                                                        size=(len(shifted_users), self._num_topics))
            self._user_preferences[shifted_users] = (
                self._shift_weight * self._user_preferences[shifted_users] +
                (1 - self._shift_weight) * new_preferences)

        return collections.OrderedDict(), collections.OrderedDict()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="reclab.environments.environment.DictEnvironment" href="environment.html#reclab.environments.environment.DictEnvironment">DictEnvironment</a></li>
<li><a title="reclab.environments.environment.Environment" href="environment.html#reclab.environments.environment.Environment">Environment</a></li>
<li>abc.ABC</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="reclab.environments.environment.DictEnvironment" href="environment.html#reclab.environments.environment.DictEnvironment">DictEnvironment</a></b></code>:
<ul class="hlist">
<li><code><a title="reclab.environments.environment.DictEnvironment.close" href="environment.html#reclab.environments.environment.Environment.close">close</a></code></li>
<li><code><a title="reclab.environments.environment.DictEnvironment.dense_ratings" href="environment.html#reclab.environments.environment.DictEnvironment.dense_ratings">dense_ratings</a></code></li>
<li><code><a title="reclab.environments.environment.DictEnvironment.items" href="environment.html#reclab.environments.environment.DictEnvironment.items">items</a></code></li>
<li><code><a title="reclab.environments.environment.DictEnvironment.name" href="environment.html#reclab.environments.environment.Environment.name">name</a></code></li>
<li><code><a title="reclab.environments.environment.DictEnvironment.online_users" href="environment.html#reclab.environments.environment.DictEnvironment.online_users">online_users</a></code></li>
<li><code><a title="reclab.environments.environment.DictEnvironment.ratings" href="environment.html#reclab.environments.environment.DictEnvironment.ratings">ratings</a></code></li>
<li><code><a title="reclab.environments.environment.DictEnvironment.reset" href="environment.html#reclab.environments.environment.DictEnvironment.reset">reset</a></code></li>
<li><code><a title="reclab.environments.environment.DictEnvironment.seed" href="environment.html#reclab.environments.environment.DictEnvironment.seed">seed</a></code></li>
<li><code><a title="reclab.environments.environment.DictEnvironment.step" href="environment.html#reclab.environments.environment.DictEnvironment.step">step</a></code></li>
<li><code><a title="reclab.environments.environment.DictEnvironment.users" href="environment.html#reclab.environments.environment.DictEnvironment.users">users</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="reclab.environments" href="index.html">reclab.environments</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="reclab.environments.topics.Topics" href="#reclab.environments.topics.Topics">Topics</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.4</a>.</p>
</footer>
</body>
</html>