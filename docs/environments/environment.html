<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.4" />
<title>reclab.environments.environment API documentation</title>
<meta name="description" content="Defines a set of base classes from which environments can inherit â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/highlight.min.js" integrity="sha256-eOgo0OtLL4cdq7RdwRUiGKLX9XsIJ7nGhWEKbohmVAQ=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>reclab.environments.environment</code></h1>
</header>
<section id="section-intro">
<p>Defines a set of base classes from which environments can inherit.</p>
<p>Environment is the interface all environments must implement. The other classes represent
specific environment variants that occur often enough to be abstract classes to inherit from.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Defines a set of base classes from which environments can inherit.

Environment is the interface all environments must implement. The other classes represent
specific environment variants that occur often enough to be abstract classes to inherit from.
&#34;&#34;&#34;
import abc
import collections

import numpy as np
from scipy.stats import norm, lognorm, pareto


class Environment(abc.ABC):
    &#34;&#34;&#34;The interface all environments must implement.&#34;&#34;&#34;

    @abc.abstractmethod
    def reset(self):
        &#34;&#34;&#34;Reset the environment to its original state. Must be called before the first step.

        Returns
        -------
        users : iterable
            New users and users whose information got updated this timestep.
        items : iterable
            New items and items whose information got updated this timestep.
        ratings : iterable
            New ratings and ratings whose information got updated this timestep.
        info : dict
            Extra information that can be used for debugging but should not be made accessible to
            the recommender.

        &#34;&#34;&#34;
        raise NotImplementedError

    @abc.abstractmethod
    def step(self, recommendations):
        &#34;&#34;&#34;Run one timestep of the environment.

        Parameters
        ----------
        recommendations : iterable
            The recommendations made to each user. The i-th recommendation should correspond to
            the i-th user that was online at this timestep.

        Returns
        -------
        users : iterable
            New users and users whose information got updated this timestep.
        items : iterable
            New items and items whose information got updated this timestep.
        ratings : iterable
            New ratings and ratings whose information got updated this timestep.
        info : dict
            Extra information that can be used for debugging but should not be made accessible to
            the recommender.

        &#34;&#34;&#34;
        raise NotImplementedError

    @abc.abstractmethod
    def online_users(self):
        &#34;&#34;&#34;Return the users that need a recommendation at the current timestep.

        Returns
        -------
        users : iterable
            The users that are online.

        &#34;&#34;&#34;
        raise NotImplementedError

    @property
    @abc.abstractmethod
    def users(self):
        &#34;&#34;&#34;Return all users currently in the environment.

        Returns
        -------
        users : iterable
            All users in the environment.

        &#34;&#34;&#34;
        raise NotImplementedError

    @property
    @abc.abstractmethod
    def items(self):
        &#34;&#34;&#34;Return all items currently in the environment.

        Returns
        -------
        items : iterable
            All items in the environment.

        &#34;&#34;&#34;
        raise NotImplementedError

    @property
    @abc.abstractmethod
    def ratings(self):
        &#34;&#34;&#34;Return all ratings that have been made in the environment.

        Returns
        -------
        ratings : iterable
            All ratings in the environment.

        &#34;&#34;&#34;
        raise NotImplementedError

    @property
    @abc.abstractmethod
    def name(self):
        &#34;&#34;&#34;Name of environment, used for saving.&#34;&#34;&#34;
        raise NotImplementedError

    def seed(self, seed=None):
        &#34;&#34;&#34;Set the seed the seed for this environment&#39;s random number generator(s).&#34;&#34;&#34;

    def close(self):
        &#34;&#34;&#34;Perform any necessary cleanup.&#34;&#34;&#34;

    def __exit__(self, *args):
        &#34;&#34;&#34;Perform any necessary cleanup when the object goes out of context.&#34;&#34;&#34;
        self.close()
        return False


class DictEnvironment(Environment):
    &#34;&#34;&#34;An environment where data gets passed around as dictionaries.

    Environments can subclass this class by implementing name, true_ratings, _rate_item and
    _reset_state. Optionally environments can also implement _update_state, _rating_env, and
    _select_online_users.

    Parameters
    ----------
    rating_frequency : float
        The proportion of users that will need a recommendation at each step.
        Must be between 0 and 1.
    num_init_ratings : int
        The number of ratings available from the start. User-item pairs are randomly selected.
    memory : int
        The number of recent items a user remembers which affect the rating
    user_dist_choice : str
        The choice of user distribution for selecting online users. By default, the subset of
        online users is chosen from a uniform distribution. Currently supports normal and lognormal.

    &#34;&#34;&#34;

    def __init__(self, rating_frequency=0.02, num_init_ratings=0, memory_length=0,
                 user_dist_choice=&#39;uniform&#39;):
        &#34;&#34;&#34;Create a Topics environment.&#34;&#34;&#34;
        self._timestep = -1
        # The RandomState to use while initializing the environment.
        self._init_random = np.random.RandomState()
        # The RandomState to use after the environment is initialized.
        self._dynamics_random = np.random.RandomState()
        self._rating_frequency = rating_frequency
        self._num_init_ratings = num_init_ratings
        self._user_dist_choice = user_dist_choice
        self._users = None
        self._items = None
        self._ratings = None
        self._dense_ratings = None
        self._online_users = None
        self._user_prob = None
        self._user_histories = collections.defaultdict(list)
        self._memory_length = memory_length

    def reset(self):
        &#34;&#34;&#34;Reset the environment to its original state. Must be called before the first step.

        Returns
        -------
        users : OrderedDict
            The initial users where the key represents the user id and the value represents
            the visible features associated with the user.
        items : OrderedDict
            The initial items where the key represents the item id and the value represents
            the visible features associated with the item.
        ratings : dict
            The initial ratings where the key is a double whose first element is the user id
            and the second element is the item id. The value represents the features associated
            with the setting in which the rating was made.

        &#34;&#34;&#34;
        # Initialize the state of the environment.
        self._timestep = -1
        self._reset_state()
        self._user_histories = collections.defaultdict(list)
        num_users = len(self._users)
        num_items = len(self._items)
        self._user_prob = self._get_user_prob()

        # We will lazily compute dense ratings.
        self._dense_ratings = None

        # Fill the rating dict with initial data.
        idx_1d = self._init_random.choice(num_users * num_items, self._num_init_ratings,
                                          replace=False,
                                          p=np.repeat(self._user_prob, num_items) / num_items)
        user_ids = idx_1d // num_items
        item_ids = idx_1d % num_items
        self._ratings = {}
        for user_id, item_id in zip(user_ids, item_ids):
            # TODO: This is a hack, but I don&#39;t think we should necessarily put the burden
            # of having to implement a version of _rate_item that knows whether it&#39;s being called
            # in reset or not on people deriving from this class. Need to think of a better way
            # than doing this though.
            temp_random = self._dynamics_random
            self._dynamics_random = self._init_random
            self._ratings[user_id, item_id] = (self._rate_item(user_id, item_id),
                                               self._rating_context(user_id))
            self._dynamics_random = temp_random

        # Finally, set the users that will be online for the first step.
        self._online_users = self._select_online_users()

        self._timestep += 1
        return self._users.copy(), self._items.copy(), self._ratings.copy()

    def step(self, recommendations):
        &#34;&#34;&#34;Run one timestep of the environment.

        Parameters
        ----------
        recommendations : np.ndarray
            The recommendations made to each user. recommendations[i] corresponds to the
            item id recommended to the i-th online user. This array must have the same size as
            the ordered dict returned by online_users.

        Returns
        -------
        users : OrderedDict
            The new users where the key represents the user id and the value represents
            the visible features associated with the user.
        items : OrderedDict
            The new items where the key represents the item id and the value represents
            the visible features associated with the item.
        ratings : dict
            The new ratings where the key is a double whose first element is the user id
            and the second element is the item id. The value represents the features associated
            with the setting in which the rating was made.
        info : dict
            Extra information for debugging and evaluation. info[&#34;users&#34;] will return the dict
            of visible user states, info[&#34;items&#34;] will return the dict of visible item states, and
            info[&#34;ratings&#34;] gets the dict of all ratings.

        &#34;&#34;&#34;
        assert len(recommendations) == len(self._online_users)
        new_users, new_items = self._update_state()
        # Old dense ratings are now invalid so set it to None and lazily recompute.
        self._dense_ratings = None

        # Get online users to rate the recommended items.
        ratings = {}
        for user_id, item_id in zip(self._online_users, recommendations):
            ratings[user_id, item_id] = (self._rate_item(user_id, item_id),
                                         self._rating_context(user_id))
            self._user_histories[user_id].append(item_id)
            if len(self._user_histories[user_id]) == self._memory_length + 1:
                self._user_histories[user_id].pop(0)
            assert len(self._user_histories[user_id]) &lt;= self._memory_length

        self._ratings.update(ratings)

        # Update the online users.
        self._online_users = self._select_online_users()

        # Create the info dict.
        info = {&#39;users&#39;: self._users,
                &#39;items&#39;: self._items,
                &#39;ratings&#39;: self._ratings}

        self._timestep += 1
        return new_users, new_items, ratings, info

    def online_users(self):
        &#34;&#34;&#34;Return the users that need a recommendation at the current timestep.

        Returns
        -------
        users_contexts : OrderedDict
            The users that are online. The key is the user id and the value is the
            features that represent the context in which the rating will be made.

        &#34;&#34;&#34;
        user_contexts = collections.OrderedDict()
        for user_id in self._online_users:
            user_contexts[user_id] = self._rating_context(user_id)
        return user_contexts

    @property
    def users(self):
        &#34;&#34;&#34;Return all users currently in the environment.

        Returns
        -------
        users : OrderedDict
            All users in the environment, the key represents the user id and the value is the
            visible features associated with the user.

        &#34;&#34;&#34;
        return self._users

    @property
    def items(self):
        &#34;&#34;&#34;Return all items currently in the environment.

        Returns
        -------
        items : OrderedDict
            All items in the environment, the key represents the item id and the value is the
            visible features associated with the item.

        &#34;&#34;&#34;
        return self._items

    @property
    def ratings(self):
        &#34;&#34;&#34;Return all ratings that have been made in the environment.

        Returns
        -------
        ratings : dict
            All ratings where the key is a double whose first element is the user id
            and the second element is the item id. The value represents the features associated
            with the setting in which the rating was made.

        &#34;&#34;&#34;
        return self._ratings

    @property
    def dense_ratings(self):
        &#34;&#34;&#34;Return all the true ratings on every user-item pair at the current timestep.

        A true rating is defined as the rating a user would make with all noise removed.

        Returns
        -------
        dense_ratings : np.ndarray
            The array of all true ratings where true_ratings[i, j] is the rating by user i
            on item j.

        &#34;&#34;&#34;
        if self._dense_ratings is None:
            self._dense_ratings = self._get_dense_ratings()
        return self._dense_ratings

    def seed(self, seed=None):
        &#34;&#34;&#34;Set the seed for this environment&#39;s random number generator.

        Parameters
        ----------
        seed : int or tuple of int
            The seed for the random number generators. If seed is an int or a tuple of length 1 all
            random number generators will be initialized with that seed. If it is a tuple of length
            2 the random number generator for the initial state of the environment will be
            initialized with seed[0] and the random number generator for the environment dynamics
            will be initialized with seed[1].

        &#34;&#34;&#34;
        if seed is None or np.issubdtype(type(seed), np.integer):
            self._init_random.seed(seed)
            self._dynamics_random.seed(seed)
        elif len(seed) == 1:
            self._init_random.seed(seed[0])
            self._dynamics_random.seed(seed[0])
        else:
            self._init_random.seed(seed[0])
            self._dynamics_random.seed(seed[1])

    @abc.abstractmethod
    def _get_dense_ratings(self):
        &#34;&#34;&#34;Compute all the true ratings on every user-item pair at the current timestep.

        A true rating is defined as the rating a user would make with all noise removed.

        Returns
        -------
        dense_ratings : np.ndarray
            The array of all true ratings where true_ratings[i, j] is the rating by user i
            on item j.

        &#34;&#34;&#34;
        raise NotImplementedError

    @abc.abstractmethod
    def _rate_item(self, user_id, item_id):
        &#34;&#34;&#34;Get a user to rate an item and update the internal rating state.

        Parameters
        ----------
        user_id : int
            The id of the user making the rating.
        item_id : int
            The id of the item being rated.

        Returns
        -------
        rating : float
            The rating the item was given by the user.

        &#34;&#34;&#34;
        raise NotImplementedError

    @abc.abstractmethod
    def _reset_state(self):
        &#34;&#34;&#34;Reset the state associated with users and items.&#34;&#34;&#34;
        raise NotImplementedError

    def _update_state(self):  # pylint: disable=no-self-use
        &#34;&#34;&#34;Update the state associated with users and items.

        The default implementation assumes there is no state that ever gets updated and no new
        users and items ever get added to the environment after being reset. If this is untrue
        you must override this function.

        Returns
        -------
        new_users : OrderedDict
            The newly added users. The key represents the user id and the value
            represents the visible features of the user.
        new_items : OrderedDict
            The newly added items. The key represents the user id and the value
            represents the visible features of the user.

        &#34;&#34;&#34;
        return collections.OrderedDict(), collections.OrderedDict()

    def _rating_context(self, user_id):  # pylint: disable=no-self-use, unused-argument
        &#34;&#34;&#34;Get the visible features of the context that the user will make the rating in.

        The default implementation assumes there are no visible features associated with each
        rating. If this is untrue you must override this function.

        Parameters
        ----------
        user_id : int
            The id of the user that will be rating an item.

        Returns
        -------
        context : np.ndarray
            The vector that represents the visible features of the context in which the given user
            will consume and rate the content.

        &#34;&#34;&#34;
        return np.zeros(0)

    def _get_user_prob(self):
        &#34;&#34;&#34;Get the probability distribution for choosing online users at each timestep.

        The default assumes that users are drawn at uniform. To modify, change the parameters
        _user_dist when initializing the environment.

        &#34;&#34;&#34;
        dist_choice = self._user_dist_choice
        num_users = len(self._users)

        if dist_choice == &#39;uniform&#39;:
            user_dist = np.ones(num_users) / num_users
        elif dist_choice == &#39;norm&#39;:
            idx = np.random.permutation(num_users)
            user_dist = np.array([norm.pdf(idx[i], scale=num_users / 7, loc=num_users / 2)
                                  for i in range(num_users)])
            user_dist = user_dist / sum(user_dist)
            user_dist = np.clip(user_dist, 0, 1)
        elif dist_choice == &#39;lognorm&#39;:
            idx = np.random.permutation(num_users)
            user_dist = np.array([lognorm.pdf(idx[i], 1, scale=num_users / 7, loc=-1)
                                  for i in range(num_users)])
            user_dist = user_dist / sum(user_dist)
            user_dist = np.clip(user_dist, 0, 1)
        elif dist_choice == &#39;pareto&#39;:
            idx = np.random.permutation(num_users)
            user_dist = np.array([pareto.pdf(idx[i], 1, scale=num_users / 1e4, loc=-1)
                                  for i in range(num_users)])
            user_dist = user_dist / sum(user_dist)
            user_dist = np.clip(user_dist, 0, 1)
        else:
            raise ValueError(&#39;user distribution name not recognized&#39;)

        return user_dist

    def _select_online_users(self):
        &#34;&#34;&#34;Select the online users at this timestep.

        Returns
        -------
        online_users : np.ndarray
            The ids of all users that are online.

        &#34;&#34;&#34;
        num_users = len(self._users)
        num_online = int(self._rating_frequency * num_users)
        return self._dynamics_random.choice(num_users, size=num_online,
                                            replace=False, p=self._user_prob)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="reclab.environments.environment.DictEnvironment"><code class="flex name class">
<span>class <span class="ident">DictEnvironment</span></span>
<span>(</span><span>rating_frequency=0.02, num_init_ratings=0, memory_length=0, user_dist_choice='uniform')</span>
</code></dt>
<dd>
<div class="desc"><p>An environment where data gets passed around as dictionaries.</p>
<p>Environments can subclass this class by implementing name, true_ratings, _rate_item and
_reset_state. Optionally environments can also implement _update_state, _rating_env, and
_select_online_users.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>rating_frequency</code></strong> :&ensp;<code>float</code></dt>
<dd>The proportion of users that will need a recommendation at each step.
Must be between 0 and 1.</dd>
<dt><strong><code>num_init_ratings</code></strong> :&ensp;<code>int</code></dt>
<dd>The number of ratings available from the start. User-item pairs are randomly selected.</dd>
<dt><strong><code>memory</code></strong> :&ensp;<code>int</code></dt>
<dd>The number of recent items a user remembers which affect the rating</dd>
<dt><strong><code>user_dist_choice</code></strong> :&ensp;<code>str</code></dt>
<dd>The choice of user distribution for selecting online users. By default, the subset of
online users is chosen from a uniform distribution. Currently supports normal and lognormal.</dd>
</dl>
<p>Create a Topics environment.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DictEnvironment(Environment):
    &#34;&#34;&#34;An environment where data gets passed around as dictionaries.

    Environments can subclass this class by implementing name, true_ratings, _rate_item and
    _reset_state. Optionally environments can also implement _update_state, _rating_env, and
    _select_online_users.

    Parameters
    ----------
    rating_frequency : float
        The proportion of users that will need a recommendation at each step.
        Must be between 0 and 1.
    num_init_ratings : int
        The number of ratings available from the start. User-item pairs are randomly selected.
    memory : int
        The number of recent items a user remembers which affect the rating
    user_dist_choice : str
        The choice of user distribution for selecting online users. By default, the subset of
        online users is chosen from a uniform distribution. Currently supports normal and lognormal.

    &#34;&#34;&#34;

    def __init__(self, rating_frequency=0.02, num_init_ratings=0, memory_length=0,
                 user_dist_choice=&#39;uniform&#39;):
        &#34;&#34;&#34;Create a Topics environment.&#34;&#34;&#34;
        self._timestep = -1
        # The RandomState to use while initializing the environment.
        self._init_random = np.random.RandomState()
        # The RandomState to use after the environment is initialized.
        self._dynamics_random = np.random.RandomState()
        self._rating_frequency = rating_frequency
        self._num_init_ratings = num_init_ratings
        self._user_dist_choice = user_dist_choice
        self._users = None
        self._items = None
        self._ratings = None
        self._dense_ratings = None
        self._online_users = None
        self._user_prob = None
        self._user_histories = collections.defaultdict(list)
        self._memory_length = memory_length

    def reset(self):
        &#34;&#34;&#34;Reset the environment to its original state. Must be called before the first step.

        Returns
        -------
        users : OrderedDict
            The initial users where the key represents the user id and the value represents
            the visible features associated with the user.
        items : OrderedDict
            The initial items where the key represents the item id and the value represents
            the visible features associated with the item.
        ratings : dict
            The initial ratings where the key is a double whose first element is the user id
            and the second element is the item id. The value represents the features associated
            with the setting in which the rating was made.

        &#34;&#34;&#34;
        # Initialize the state of the environment.
        self._timestep = -1
        self._reset_state()
        self._user_histories = collections.defaultdict(list)
        num_users = len(self._users)
        num_items = len(self._items)
        self._user_prob = self._get_user_prob()

        # We will lazily compute dense ratings.
        self._dense_ratings = None

        # Fill the rating dict with initial data.
        idx_1d = self._init_random.choice(num_users * num_items, self._num_init_ratings,
                                          replace=False,
                                          p=np.repeat(self._user_prob, num_items) / num_items)
        user_ids = idx_1d // num_items
        item_ids = idx_1d % num_items
        self._ratings = {}
        for user_id, item_id in zip(user_ids, item_ids):
            # TODO: This is a hack, but I don&#39;t think we should necessarily put the burden
            # of having to implement a version of _rate_item that knows whether it&#39;s being called
            # in reset or not on people deriving from this class. Need to think of a better way
            # than doing this though.
            temp_random = self._dynamics_random
            self._dynamics_random = self._init_random
            self._ratings[user_id, item_id] = (self._rate_item(user_id, item_id),
                                               self._rating_context(user_id))
            self._dynamics_random = temp_random

        # Finally, set the users that will be online for the first step.
        self._online_users = self._select_online_users()

        self._timestep += 1
        return self._users.copy(), self._items.copy(), self._ratings.copy()

    def step(self, recommendations):
        &#34;&#34;&#34;Run one timestep of the environment.

        Parameters
        ----------
        recommendations : np.ndarray
            The recommendations made to each user. recommendations[i] corresponds to the
            item id recommended to the i-th online user. This array must have the same size as
            the ordered dict returned by online_users.

        Returns
        -------
        users : OrderedDict
            The new users where the key represents the user id and the value represents
            the visible features associated with the user.
        items : OrderedDict
            The new items where the key represents the item id and the value represents
            the visible features associated with the item.
        ratings : dict
            The new ratings where the key is a double whose first element is the user id
            and the second element is the item id. The value represents the features associated
            with the setting in which the rating was made.
        info : dict
            Extra information for debugging and evaluation. info[&#34;users&#34;] will return the dict
            of visible user states, info[&#34;items&#34;] will return the dict of visible item states, and
            info[&#34;ratings&#34;] gets the dict of all ratings.

        &#34;&#34;&#34;
        assert len(recommendations) == len(self._online_users)
        new_users, new_items = self._update_state()
        # Old dense ratings are now invalid so set it to None and lazily recompute.
        self._dense_ratings = None

        # Get online users to rate the recommended items.
        ratings = {}
        for user_id, item_id in zip(self._online_users, recommendations):
            ratings[user_id, item_id] = (self._rate_item(user_id, item_id),
                                         self._rating_context(user_id))
            self._user_histories[user_id].append(item_id)
            if len(self._user_histories[user_id]) == self._memory_length + 1:
                self._user_histories[user_id].pop(0)
            assert len(self._user_histories[user_id]) &lt;= self._memory_length

        self._ratings.update(ratings)

        # Update the online users.
        self._online_users = self._select_online_users()

        # Create the info dict.
        info = {&#39;users&#39;: self._users,
                &#39;items&#39;: self._items,
                &#39;ratings&#39;: self._ratings}

        self._timestep += 1
        return new_users, new_items, ratings, info

    def online_users(self):
        &#34;&#34;&#34;Return the users that need a recommendation at the current timestep.

        Returns
        -------
        users_contexts : OrderedDict
            The users that are online. The key is the user id and the value is the
            features that represent the context in which the rating will be made.

        &#34;&#34;&#34;
        user_contexts = collections.OrderedDict()
        for user_id in self._online_users:
            user_contexts[user_id] = self._rating_context(user_id)
        return user_contexts

    @property
    def users(self):
        &#34;&#34;&#34;Return all users currently in the environment.

        Returns
        -------
        users : OrderedDict
            All users in the environment, the key represents the user id and the value is the
            visible features associated with the user.

        &#34;&#34;&#34;
        return self._users

    @property
    def items(self):
        &#34;&#34;&#34;Return all items currently in the environment.

        Returns
        -------
        items : OrderedDict
            All items in the environment, the key represents the item id and the value is the
            visible features associated with the item.

        &#34;&#34;&#34;
        return self._items

    @property
    def ratings(self):
        &#34;&#34;&#34;Return all ratings that have been made in the environment.

        Returns
        -------
        ratings : dict
            All ratings where the key is a double whose first element is the user id
            and the second element is the item id. The value represents the features associated
            with the setting in which the rating was made.

        &#34;&#34;&#34;
        return self._ratings

    @property
    def dense_ratings(self):
        &#34;&#34;&#34;Return all the true ratings on every user-item pair at the current timestep.

        A true rating is defined as the rating a user would make with all noise removed.

        Returns
        -------
        dense_ratings : np.ndarray
            The array of all true ratings where true_ratings[i, j] is the rating by user i
            on item j.

        &#34;&#34;&#34;
        if self._dense_ratings is None:
            self._dense_ratings = self._get_dense_ratings()
        return self._dense_ratings

    def seed(self, seed=None):
        &#34;&#34;&#34;Set the seed for this environment&#39;s random number generator.

        Parameters
        ----------
        seed : int or tuple of int
            The seed for the random number generators. If seed is an int or a tuple of length 1 all
            random number generators will be initialized with that seed. If it is a tuple of length
            2 the random number generator for the initial state of the environment will be
            initialized with seed[0] and the random number generator for the environment dynamics
            will be initialized with seed[1].

        &#34;&#34;&#34;
        if seed is None or np.issubdtype(type(seed), np.integer):
            self._init_random.seed(seed)
            self._dynamics_random.seed(seed)
        elif len(seed) == 1:
            self._init_random.seed(seed[0])
            self._dynamics_random.seed(seed[0])
        else:
            self._init_random.seed(seed[0])
            self._dynamics_random.seed(seed[1])

    @abc.abstractmethod
    def _get_dense_ratings(self):
        &#34;&#34;&#34;Compute all the true ratings on every user-item pair at the current timestep.

        A true rating is defined as the rating a user would make with all noise removed.

        Returns
        -------
        dense_ratings : np.ndarray
            The array of all true ratings where true_ratings[i, j] is the rating by user i
            on item j.

        &#34;&#34;&#34;
        raise NotImplementedError

    @abc.abstractmethod
    def _rate_item(self, user_id, item_id):
        &#34;&#34;&#34;Get a user to rate an item and update the internal rating state.

        Parameters
        ----------
        user_id : int
            The id of the user making the rating.
        item_id : int
            The id of the item being rated.

        Returns
        -------
        rating : float
            The rating the item was given by the user.

        &#34;&#34;&#34;
        raise NotImplementedError

    @abc.abstractmethod
    def _reset_state(self):
        &#34;&#34;&#34;Reset the state associated with users and items.&#34;&#34;&#34;
        raise NotImplementedError

    def _update_state(self):  # pylint: disable=no-self-use
        &#34;&#34;&#34;Update the state associated with users and items.

        The default implementation assumes there is no state that ever gets updated and no new
        users and items ever get added to the environment after being reset. If this is untrue
        you must override this function.

        Returns
        -------
        new_users : OrderedDict
            The newly added users. The key represents the user id and the value
            represents the visible features of the user.
        new_items : OrderedDict
            The newly added items. The key represents the user id and the value
            represents the visible features of the user.

        &#34;&#34;&#34;
        return collections.OrderedDict(), collections.OrderedDict()

    def _rating_context(self, user_id):  # pylint: disable=no-self-use, unused-argument
        &#34;&#34;&#34;Get the visible features of the context that the user will make the rating in.

        The default implementation assumes there are no visible features associated with each
        rating. If this is untrue you must override this function.

        Parameters
        ----------
        user_id : int
            The id of the user that will be rating an item.

        Returns
        -------
        context : np.ndarray
            The vector that represents the visible features of the context in which the given user
            will consume and rate the content.

        &#34;&#34;&#34;
        return np.zeros(0)

    def _get_user_prob(self):
        &#34;&#34;&#34;Get the probability distribution for choosing online users at each timestep.

        The default assumes that users are drawn at uniform. To modify, change the parameters
        _user_dist when initializing the environment.

        &#34;&#34;&#34;
        dist_choice = self._user_dist_choice
        num_users = len(self._users)

        if dist_choice == &#39;uniform&#39;:
            user_dist = np.ones(num_users) / num_users
        elif dist_choice == &#39;norm&#39;:
            idx = np.random.permutation(num_users)
            user_dist = np.array([norm.pdf(idx[i], scale=num_users / 7, loc=num_users / 2)
                                  for i in range(num_users)])
            user_dist = user_dist / sum(user_dist)
            user_dist = np.clip(user_dist, 0, 1)
        elif dist_choice == &#39;lognorm&#39;:
            idx = np.random.permutation(num_users)
            user_dist = np.array([lognorm.pdf(idx[i], 1, scale=num_users / 7, loc=-1)
                                  for i in range(num_users)])
            user_dist = user_dist / sum(user_dist)
            user_dist = np.clip(user_dist, 0, 1)
        elif dist_choice == &#39;pareto&#39;:
            idx = np.random.permutation(num_users)
            user_dist = np.array([pareto.pdf(idx[i], 1, scale=num_users / 1e4, loc=-1)
                                  for i in range(num_users)])
            user_dist = user_dist / sum(user_dist)
            user_dist = np.clip(user_dist, 0, 1)
        else:
            raise ValueError(&#39;user distribution name not recognized&#39;)

        return user_dist

    def _select_online_users(self):
        &#34;&#34;&#34;Select the online users at this timestep.

        Returns
        -------
        online_users : np.ndarray
            The ids of all users that are online.

        &#34;&#34;&#34;
        num_users = len(self._users)
        num_online = int(self._rating_frequency * num_users)
        return self._dynamics_random.choice(num_users, size=num_online,
                                            replace=False, p=self._user_prob)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="reclab.environments.environment.Environment" href="#reclab.environments.environment.Environment">Environment</a></li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="reclab.environments.engelhardt.Engelhardt" href="engelhardt.html#reclab.environments.engelhardt.Engelhardt">Engelhardt</a></li>
<li><a title="reclab.environments.fixed_rating.FixedRating" href="fixed_rating.html#reclab.environments.fixed_rating.FixedRating">FixedRating</a></li>
<li><a title="reclab.environments.latent_factors.LatentFactorBehavior" href="latent_factors.html#reclab.environments.latent_factors.LatentFactorBehavior">LatentFactorBehavior</a></li>
<li><a title="reclab.environments.schmit.Schmit" href="schmit.html#reclab.environments.schmit.Schmit">Schmit</a></li>
<li><a title="reclab.environments.topics.Topics" href="topics.html#reclab.environments.topics.Topics">Topics</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="reclab.environments.environment.DictEnvironment.dense_ratings"><code class="name">var <span class="ident">dense_ratings</span></code></dt>
<dd>
<div class="desc"><p>Return all the true ratings on every user-item pair at the current timestep.</p>
<p>A true rating is defined as the rating a user would make with all noise removed.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>dense_ratings</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>The array of all true ratings where true_ratings[i, j] is the rating by user i
on item j.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def dense_ratings(self):
    &#34;&#34;&#34;Return all the true ratings on every user-item pair at the current timestep.

    A true rating is defined as the rating a user would make with all noise removed.

    Returns
    -------
    dense_ratings : np.ndarray
        The array of all true ratings where true_ratings[i, j] is the rating by user i
        on item j.

    &#34;&#34;&#34;
    if self._dense_ratings is None:
        self._dense_ratings = self._get_dense_ratings()
    return self._dense_ratings</code></pre>
</details>
</dd>
<dt id="reclab.environments.environment.DictEnvironment.items"><code class="name">var <span class="ident">items</span></code></dt>
<dd>
<div class="desc"><p>Return all items currently in the environment.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>items</code></strong> :&ensp;<code>OrderedDict</code></dt>
<dd>All items in the environment, the key represents the item id and the value is the
visible features associated with the item.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def items(self):
    &#34;&#34;&#34;Return all items currently in the environment.

    Returns
    -------
    items : OrderedDict
        All items in the environment, the key represents the item id and the value is the
        visible features associated with the item.

    &#34;&#34;&#34;
    return self._items</code></pre>
</details>
</dd>
<dt id="reclab.environments.environment.DictEnvironment.ratings"><code class="name">var <span class="ident">ratings</span></code></dt>
<dd>
<div class="desc"><p>Return all ratings that have been made in the environment.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>ratings</code></strong> :&ensp;<code>dict</code></dt>
<dd>All ratings where the key is a double whose first element is the user id
and the second element is the item id. The value represents the features associated
with the setting in which the rating was made.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def ratings(self):
    &#34;&#34;&#34;Return all ratings that have been made in the environment.

    Returns
    -------
    ratings : dict
        All ratings where the key is a double whose first element is the user id
        and the second element is the item id. The value represents the features associated
        with the setting in which the rating was made.

    &#34;&#34;&#34;
    return self._ratings</code></pre>
</details>
</dd>
<dt id="reclab.environments.environment.DictEnvironment.users"><code class="name">var <span class="ident">users</span></code></dt>
<dd>
<div class="desc"><p>Return all users currently in the environment.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>users</code></strong> :&ensp;<code>OrderedDict</code></dt>
<dd>All users in the environment, the key represents the user id and the value is the
visible features associated with the user.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def users(self):
    &#34;&#34;&#34;Return all users currently in the environment.

    Returns
    -------
    users : OrderedDict
        All users in the environment, the key represents the user id and the value is the
        visible features associated with the user.

    &#34;&#34;&#34;
    return self._users</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="reclab.environments.environment.DictEnvironment.online_users"><code class="name flex">
<span>def <span class="ident">online_users</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the users that need a recommendation at the current timestep.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>users_contexts</code></strong> :&ensp;<code>OrderedDict</code></dt>
<dd>The users that are online. The key is the user id and the value is the
features that represent the context in which the rating will be made.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def online_users(self):
    &#34;&#34;&#34;Return the users that need a recommendation at the current timestep.

    Returns
    -------
    users_contexts : OrderedDict
        The users that are online. The key is the user id and the value is the
        features that represent the context in which the rating will be made.

    &#34;&#34;&#34;
    user_contexts = collections.OrderedDict()
    for user_id in self._online_users:
        user_contexts[user_id] = self._rating_context(user_id)
    return user_contexts</code></pre>
</details>
</dd>
<dt id="reclab.environments.environment.DictEnvironment.reset"><code class="name flex">
<span>def <span class="ident">reset</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Reset the environment to its original state. Must be called before the first step.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>users</code></strong> :&ensp;<code>OrderedDict</code></dt>
<dd>The initial users where the key represents the user id and the value represents
the visible features associated with the user.</dd>
<dt><strong><code>items</code></strong> :&ensp;<code>OrderedDict</code></dt>
<dd>The initial items where the key represents the item id and the value represents
the visible features associated with the item.</dd>
<dt><strong><code>ratings</code></strong> :&ensp;<code>dict</code></dt>
<dd>The initial ratings where the key is a double whose first element is the user id
and the second element is the item id. The value represents the features associated
with the setting in which the rating was made.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reset(self):
    &#34;&#34;&#34;Reset the environment to its original state. Must be called before the first step.

    Returns
    -------
    users : OrderedDict
        The initial users where the key represents the user id and the value represents
        the visible features associated with the user.
    items : OrderedDict
        The initial items where the key represents the item id and the value represents
        the visible features associated with the item.
    ratings : dict
        The initial ratings where the key is a double whose first element is the user id
        and the second element is the item id. The value represents the features associated
        with the setting in which the rating was made.

    &#34;&#34;&#34;
    # Initialize the state of the environment.
    self._timestep = -1
    self._reset_state()
    self._user_histories = collections.defaultdict(list)
    num_users = len(self._users)
    num_items = len(self._items)
    self._user_prob = self._get_user_prob()

    # We will lazily compute dense ratings.
    self._dense_ratings = None

    # Fill the rating dict with initial data.
    idx_1d = self._init_random.choice(num_users * num_items, self._num_init_ratings,
                                      replace=False,
                                      p=np.repeat(self._user_prob, num_items) / num_items)
    user_ids = idx_1d // num_items
    item_ids = idx_1d % num_items
    self._ratings = {}
    for user_id, item_id in zip(user_ids, item_ids):
        # TODO: This is a hack, but I don&#39;t think we should necessarily put the burden
        # of having to implement a version of _rate_item that knows whether it&#39;s being called
        # in reset or not on people deriving from this class. Need to think of a better way
        # than doing this though.
        temp_random = self._dynamics_random
        self._dynamics_random = self._init_random
        self._ratings[user_id, item_id] = (self._rate_item(user_id, item_id),
                                           self._rating_context(user_id))
        self._dynamics_random = temp_random

    # Finally, set the users that will be online for the first step.
    self._online_users = self._select_online_users()

    self._timestep += 1
    return self._users.copy(), self._items.copy(), self._ratings.copy()</code></pre>
</details>
</dd>
<dt id="reclab.environments.environment.DictEnvironment.seed"><code class="name flex">
<span>def <span class="ident">seed</span></span>(<span>self, seed=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the seed for this environment's random number generator.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>seed</code></strong> :&ensp;<code>int</code> or <code>tuple</code> of <code>int</code></dt>
<dd>The seed for the random number generators. If seed is an int or a tuple of length 1 all
random number generators will be initialized with that seed. If it is a tuple of length
2 the random number generator for the initial state of the environment will be
initialized with seed[0] and the random number generator for the environment dynamics
will be initialized with seed[1].</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def seed(self, seed=None):
    &#34;&#34;&#34;Set the seed for this environment&#39;s random number generator.

    Parameters
    ----------
    seed : int or tuple of int
        The seed for the random number generators. If seed is an int or a tuple of length 1 all
        random number generators will be initialized with that seed. If it is a tuple of length
        2 the random number generator for the initial state of the environment will be
        initialized with seed[0] and the random number generator for the environment dynamics
        will be initialized with seed[1].

    &#34;&#34;&#34;
    if seed is None or np.issubdtype(type(seed), np.integer):
        self._init_random.seed(seed)
        self._dynamics_random.seed(seed)
    elif len(seed) == 1:
        self._init_random.seed(seed[0])
        self._dynamics_random.seed(seed[0])
    else:
        self._init_random.seed(seed[0])
        self._dynamics_random.seed(seed[1])</code></pre>
</details>
</dd>
<dt id="reclab.environments.environment.DictEnvironment.step"><code class="name flex">
<span>def <span class="ident">step</span></span>(<span>self, recommendations)</span>
</code></dt>
<dd>
<div class="desc"><p>Run one timestep of the environment.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>recommendations</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>The recommendations made to each user. recommendations[i] corresponds to the
item id recommended to the i-th online user. This array must have the same size as
the ordered dict returned by online_users.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>users</code></strong> :&ensp;<code>OrderedDict</code></dt>
<dd>The new users where the key represents the user id and the value represents
the visible features associated with the user.</dd>
<dt><strong><code>items</code></strong> :&ensp;<code>OrderedDict</code></dt>
<dd>The new items where the key represents the item id and the value represents
the visible features associated with the item.</dd>
<dt><strong><code>ratings</code></strong> :&ensp;<code>dict</code></dt>
<dd>The new ratings where the key is a double whose first element is the user id
and the second element is the item id. The value represents the features associated
with the setting in which the rating was made.</dd>
<dt><strong><code>info</code></strong> :&ensp;<code>dict</code></dt>
<dd>Extra information for debugging and evaluation. info["users"] will return the dict
of visible user states, info["items"] will return the dict of visible item states, and
info["ratings"] gets the dict of all ratings.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def step(self, recommendations):
    &#34;&#34;&#34;Run one timestep of the environment.

    Parameters
    ----------
    recommendations : np.ndarray
        The recommendations made to each user. recommendations[i] corresponds to the
        item id recommended to the i-th online user. This array must have the same size as
        the ordered dict returned by online_users.

    Returns
    -------
    users : OrderedDict
        The new users where the key represents the user id and the value represents
        the visible features associated with the user.
    items : OrderedDict
        The new items where the key represents the item id and the value represents
        the visible features associated with the item.
    ratings : dict
        The new ratings where the key is a double whose first element is the user id
        and the second element is the item id. The value represents the features associated
        with the setting in which the rating was made.
    info : dict
        Extra information for debugging and evaluation. info[&#34;users&#34;] will return the dict
        of visible user states, info[&#34;items&#34;] will return the dict of visible item states, and
        info[&#34;ratings&#34;] gets the dict of all ratings.

    &#34;&#34;&#34;
    assert len(recommendations) == len(self._online_users)
    new_users, new_items = self._update_state()
    # Old dense ratings are now invalid so set it to None and lazily recompute.
    self._dense_ratings = None

    # Get online users to rate the recommended items.
    ratings = {}
    for user_id, item_id in zip(self._online_users, recommendations):
        ratings[user_id, item_id] = (self._rate_item(user_id, item_id),
                                     self._rating_context(user_id))
        self._user_histories[user_id].append(item_id)
        if len(self._user_histories[user_id]) == self._memory_length + 1:
            self._user_histories[user_id].pop(0)
        assert len(self._user_histories[user_id]) &lt;= self._memory_length

    self._ratings.update(ratings)

    # Update the online users.
    self._online_users = self._select_online_users()

    # Create the info dict.
    info = {&#39;users&#39;: self._users,
            &#39;items&#39;: self._items,
            &#39;ratings&#39;: self._ratings}

    self._timestep += 1
    return new_users, new_items, ratings, info</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="reclab.environments.environment.Environment" href="#reclab.environments.environment.Environment">Environment</a></b></code>:
<ul class="hlist">
<li><code><a title="reclab.environments.environment.Environment.close" href="#reclab.environments.environment.Environment.close">close</a></code></li>
<li><code><a title="reclab.environments.environment.Environment.name" href="#reclab.environments.environment.Environment.name">name</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="reclab.environments.environment.Environment"><code class="flex name class">
<span>class <span class="ident">Environment</span></span>
</code></dt>
<dd>
<div class="desc"><p>The interface all environments must implement.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Environment(abc.ABC):
    &#34;&#34;&#34;The interface all environments must implement.&#34;&#34;&#34;

    @abc.abstractmethod
    def reset(self):
        &#34;&#34;&#34;Reset the environment to its original state. Must be called before the first step.

        Returns
        -------
        users : iterable
            New users and users whose information got updated this timestep.
        items : iterable
            New items and items whose information got updated this timestep.
        ratings : iterable
            New ratings and ratings whose information got updated this timestep.
        info : dict
            Extra information that can be used for debugging but should not be made accessible to
            the recommender.

        &#34;&#34;&#34;
        raise NotImplementedError

    @abc.abstractmethod
    def step(self, recommendations):
        &#34;&#34;&#34;Run one timestep of the environment.

        Parameters
        ----------
        recommendations : iterable
            The recommendations made to each user. The i-th recommendation should correspond to
            the i-th user that was online at this timestep.

        Returns
        -------
        users : iterable
            New users and users whose information got updated this timestep.
        items : iterable
            New items and items whose information got updated this timestep.
        ratings : iterable
            New ratings and ratings whose information got updated this timestep.
        info : dict
            Extra information that can be used for debugging but should not be made accessible to
            the recommender.

        &#34;&#34;&#34;
        raise NotImplementedError

    @abc.abstractmethod
    def online_users(self):
        &#34;&#34;&#34;Return the users that need a recommendation at the current timestep.

        Returns
        -------
        users : iterable
            The users that are online.

        &#34;&#34;&#34;
        raise NotImplementedError

    @property
    @abc.abstractmethod
    def users(self):
        &#34;&#34;&#34;Return all users currently in the environment.

        Returns
        -------
        users : iterable
            All users in the environment.

        &#34;&#34;&#34;
        raise NotImplementedError

    @property
    @abc.abstractmethod
    def items(self):
        &#34;&#34;&#34;Return all items currently in the environment.

        Returns
        -------
        items : iterable
            All items in the environment.

        &#34;&#34;&#34;
        raise NotImplementedError

    @property
    @abc.abstractmethod
    def ratings(self):
        &#34;&#34;&#34;Return all ratings that have been made in the environment.

        Returns
        -------
        ratings : iterable
            All ratings in the environment.

        &#34;&#34;&#34;
        raise NotImplementedError

    @property
    @abc.abstractmethod
    def name(self):
        &#34;&#34;&#34;Name of environment, used for saving.&#34;&#34;&#34;
        raise NotImplementedError

    def seed(self, seed=None):
        &#34;&#34;&#34;Set the seed the seed for this environment&#39;s random number generator(s).&#34;&#34;&#34;

    def close(self):
        &#34;&#34;&#34;Perform any necessary cleanup.&#34;&#34;&#34;

    def __exit__(self, *args):
        &#34;&#34;&#34;Perform any necessary cleanup when the object goes out of context.&#34;&#34;&#34;
        self.close()
        return False</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="reclab.environments.environment.DictEnvironment" href="#reclab.environments.environment.DictEnvironment">DictEnvironment</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="reclab.environments.environment.Environment.items"><code class="name">var <span class="ident">items</span></code></dt>
<dd>
<div class="desc"><p>Return all items currently in the environment.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>items</code></strong> :&ensp;<code>iterable</code></dt>
<dd>All items in the environment.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
@abc.abstractmethod
def items(self):
    &#34;&#34;&#34;Return all items currently in the environment.

    Returns
    -------
    items : iterable
        All items in the environment.

    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="reclab.environments.environment.Environment.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"><p>Name of environment, used for saving.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
@abc.abstractmethod
def name(self):
    &#34;&#34;&#34;Name of environment, used for saving.&#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="reclab.environments.environment.Environment.ratings"><code class="name">var <span class="ident">ratings</span></code></dt>
<dd>
<div class="desc"><p>Return all ratings that have been made in the environment.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>ratings</code></strong> :&ensp;<code>iterable</code></dt>
<dd>All ratings in the environment.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
@abc.abstractmethod
def ratings(self):
    &#34;&#34;&#34;Return all ratings that have been made in the environment.

    Returns
    -------
    ratings : iterable
        All ratings in the environment.

    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="reclab.environments.environment.Environment.users"><code class="name">var <span class="ident">users</span></code></dt>
<dd>
<div class="desc"><p>Return all users currently in the environment.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>users</code></strong> :&ensp;<code>iterable</code></dt>
<dd>All users in the environment.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
@abc.abstractmethod
def users(self):
    &#34;&#34;&#34;Return all users currently in the environment.

    Returns
    -------
    users : iterable
        All users in the environment.

    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="reclab.environments.environment.Environment.close"><code class="name flex">
<span>def <span class="ident">close</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Perform any necessary cleanup.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def close(self):
    &#34;&#34;&#34;Perform any necessary cleanup.&#34;&#34;&#34;</code></pre>
</details>
</dd>
<dt id="reclab.environments.environment.Environment.online_users"><code class="name flex">
<span>def <span class="ident">online_users</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the users that need a recommendation at the current timestep.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>users</code></strong> :&ensp;<code>iterable</code></dt>
<dd>The users that are online.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractmethod
def online_users(self):
    &#34;&#34;&#34;Return the users that need a recommendation at the current timestep.

    Returns
    -------
    users : iterable
        The users that are online.

    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="reclab.environments.environment.Environment.reset"><code class="name flex">
<span>def <span class="ident">reset</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Reset the environment to its original state. Must be called before the first step.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>users</code></strong> :&ensp;<code>iterable</code></dt>
<dd>New users and users whose information got updated this timestep.</dd>
<dt><strong><code>items</code></strong> :&ensp;<code>iterable</code></dt>
<dd>New items and items whose information got updated this timestep.</dd>
<dt><strong><code>ratings</code></strong> :&ensp;<code>iterable</code></dt>
<dd>New ratings and ratings whose information got updated this timestep.</dd>
<dt><strong><code>info</code></strong> :&ensp;<code>dict</code></dt>
<dd>Extra information that can be used for debugging but should not be made accessible to
the recommender.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractmethod
def reset(self):
    &#34;&#34;&#34;Reset the environment to its original state. Must be called before the first step.

    Returns
    -------
    users : iterable
        New users and users whose information got updated this timestep.
    items : iterable
        New items and items whose information got updated this timestep.
    ratings : iterable
        New ratings and ratings whose information got updated this timestep.
    info : dict
        Extra information that can be used for debugging but should not be made accessible to
        the recommender.

    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="reclab.environments.environment.Environment.seed"><code class="name flex">
<span>def <span class="ident">seed</span></span>(<span>self, seed=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the seed the seed for this environment's random number generator(s).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def seed(self, seed=None):
    &#34;&#34;&#34;Set the seed the seed for this environment&#39;s random number generator(s).&#34;&#34;&#34;</code></pre>
</details>
</dd>
<dt id="reclab.environments.environment.Environment.step"><code class="name flex">
<span>def <span class="ident">step</span></span>(<span>self, recommendations)</span>
</code></dt>
<dd>
<div class="desc"><p>Run one timestep of the environment.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>recommendations</code></strong> :&ensp;<code>iterable</code></dt>
<dd>The recommendations made to each user. The i-th recommendation should correspond to
the i-th user that was online at this timestep.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>users</code></strong> :&ensp;<code>iterable</code></dt>
<dd>New users and users whose information got updated this timestep.</dd>
<dt><strong><code>items</code></strong> :&ensp;<code>iterable</code></dt>
<dd>New items and items whose information got updated this timestep.</dd>
<dt><strong><code>ratings</code></strong> :&ensp;<code>iterable</code></dt>
<dd>New ratings and ratings whose information got updated this timestep.</dd>
<dt><strong><code>info</code></strong> :&ensp;<code>dict</code></dt>
<dd>Extra information that can be used for debugging but should not be made accessible to
the recommender.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractmethod
def step(self, recommendations):
    &#34;&#34;&#34;Run one timestep of the environment.

    Parameters
    ----------
    recommendations : iterable
        The recommendations made to each user. The i-th recommendation should correspond to
        the i-th user that was online at this timestep.

    Returns
    -------
    users : iterable
        New users and users whose information got updated this timestep.
    items : iterable
        New items and items whose information got updated this timestep.
    ratings : iterable
        New ratings and ratings whose information got updated this timestep.
    info : dict
        Extra information that can be used for debugging but should not be made accessible to
        the recommender.

    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="reclab.environments" href="index.html">reclab.environments</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="reclab.environments.environment.DictEnvironment" href="#reclab.environments.environment.DictEnvironment">DictEnvironment</a></code></h4>
<ul class="two-column">
<li><code><a title="reclab.environments.environment.DictEnvironment.dense_ratings" href="#reclab.environments.environment.DictEnvironment.dense_ratings">dense_ratings</a></code></li>
<li><code><a title="reclab.environments.environment.DictEnvironment.items" href="#reclab.environments.environment.DictEnvironment.items">items</a></code></li>
<li><code><a title="reclab.environments.environment.DictEnvironment.online_users" href="#reclab.environments.environment.DictEnvironment.online_users">online_users</a></code></li>
<li><code><a title="reclab.environments.environment.DictEnvironment.ratings" href="#reclab.environments.environment.DictEnvironment.ratings">ratings</a></code></li>
<li><code><a title="reclab.environments.environment.DictEnvironment.reset" href="#reclab.environments.environment.DictEnvironment.reset">reset</a></code></li>
<li><code><a title="reclab.environments.environment.DictEnvironment.seed" href="#reclab.environments.environment.DictEnvironment.seed">seed</a></code></li>
<li><code><a title="reclab.environments.environment.DictEnvironment.step" href="#reclab.environments.environment.DictEnvironment.step">step</a></code></li>
<li><code><a title="reclab.environments.environment.DictEnvironment.users" href="#reclab.environments.environment.DictEnvironment.users">users</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="reclab.environments.environment.Environment" href="#reclab.environments.environment.Environment">Environment</a></code></h4>
<ul class="two-column">
<li><code><a title="reclab.environments.environment.Environment.close" href="#reclab.environments.environment.Environment.close">close</a></code></li>
<li><code><a title="reclab.environments.environment.Environment.items" href="#reclab.environments.environment.Environment.items">items</a></code></li>
<li><code><a title="reclab.environments.environment.Environment.name" href="#reclab.environments.environment.Environment.name">name</a></code></li>
<li><code><a title="reclab.environments.environment.Environment.online_users" href="#reclab.environments.environment.Environment.online_users">online_users</a></code></li>
<li><code><a title="reclab.environments.environment.Environment.ratings" href="#reclab.environments.environment.Environment.ratings">ratings</a></code></li>
<li><code><a title="reclab.environments.environment.Environment.reset" href="#reclab.environments.environment.Environment.reset">reset</a></code></li>
<li><code><a title="reclab.environments.environment.Environment.seed" href="#reclab.environments.environment.Environment.seed">seed</a></code></li>
<li><code><a title="reclab.environments.environment.Environment.step" href="#reclab.environments.environment.Environment.step">step</a></code></li>
<li><code><a title="reclab.environments.environment.Environment.users" href="#reclab.environments.environment.Environment.users">users</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.4</a>.</p>
</footer>
</body>
</html>